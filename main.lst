CCS PCM C Compiler, Version 5.007, 61971               28-Oca-24 22:57

               Filename:   C:\Users\bune_\Desktop\project_PIC\main.lst

               ROM used:   3079 words (38%)
                           Largest free fragment is 2048
               RAM used:   44 (12%) at main() level
                           59 (16%) worst case
               Stack used: 1 locations (0 in main + 1 for interrupts)
               Stack size: 8

*
0000:  MOVLW  08
0001:  MOVWF  0A
0002:  GOTO   000
0003:  NOP
0004:  MOVWF  7F
0005:  SWAPF  03,W
0006:  CLRF   03
0007:  MOVWF  21
0008:  MOVF   0A,W
0009:  MOVWF  20
000A:  CLRF   0A
000B:  MOVF   04,W
000C:  MOVWF  22
000D:  MOVF   77,W
000E:  MOVWF  23
000F:  MOVF   78,W
0010:  MOVWF  24
0011:  MOVF   79,W
0012:  MOVWF  25
0013:  MOVF   7A,W
0014:  MOVWF  26
0015:  BCF    03.7
0016:  BCF    03.5
0017:  MOVLW  8C
0018:  MOVWF  04
0019:  BTFSS  00.0
001A:  GOTO   01D
001B:  BTFSC  0C.0
001C:  GOTO   032
001D:  BTFSS  0B.5
001E:  GOTO   021
001F:  BTFSC  0B.2
0020:  GOTO   035
0021:  MOVF   22,W
0022:  MOVWF  04
0023:  MOVF   23,W
0024:  MOVWF  77
0025:  MOVF   24,W
0026:  MOVWF  78
0027:  MOVF   25,W
0028:  MOVWF  79
0029:  MOVF   26,W
002A:  MOVWF  7A
002B:  MOVF   20,W
002C:  MOVWF  0A
002D:  SWAPF  21,W
002E:  MOVWF  03
002F:  SWAPF  7F,F
0030:  SWAPF  7F,W
0031:  RETFIE
0032:  BCF    0A.3
0033:  BCF    0A.4
0034:  GOTO   047
0035:  BCF    0A.3
0036:  BCF    0A.4
0037:  GOTO   040
.................... #include <16F877A.h> 
.................... //////// Standard Header file for the PIC16F877A device //////////////// 
.................... #device PIC16F877A 
0038:  BCF    0A.0
0039:  BCF    0A.1
003A:  BCF    0A.2
003B:  ADDWF  02,F
003C:  RETLW  28
003D:  RETLW  0C
003E:  RETLW  01
003F:  RETLW  06
*
0061:  DATA CB,27
0062:  DATA 55,10
0063:  DATA 2D,10
0064:  DATA CD,24
0065:  DATA 4B,29
0066:  DATA 4F,00
0067:  DATA 20,10
0068:  DATA 20,28
0069:  DATA D2,27
006A:  DATA CA,22
006B:  DATA 00,01
006C:  DATA 8C,2A
006D:  DATA ED,3A
006E:  DATA F4,31
006F:  DATA 61,37
0070:  DATA A0,23
0071:  DATA CF,25
0072:  DATA 00,01
0073:  DATA 31,1C
0074:  DATA 30,19
0075:  DATA B2,19
0076:  DATA 30,1A
0077:  DATA 37,00
0078:  DATA 8C,29
0079:  DATA E9,31
007A:  DATA E1,35
007B:  DATA EC,34
007C:  DATA 6B,1D
007D:  DATA 25,32
007E:  DATA 43,16
007F:  DATA CE,32
0080:  DATA 6D,1D
0081:  DATA 25,32
0082:  DATA 00,00
0083:  DATA C7,30
0084:  DATA 7A,14
0085:  DATA B1,17
0086:  DATA B0,14
0087:  DATA BA,12
0088:  DATA 64,00
0089:  DATA 8C,29
008A:  DATA E9,31
008B:  DATA E1,35
008C:  DATA EC,34
008D:  DATA 6B,1D
008E:  DATA 25,32
008F:  DATA 43,16
0090:  DATA 20,27
0091:  DATA E5,36
0092:  DATA BA,12
0093:  DATA 64,05
0094:  DATA 00,01
0095:  DATA 20,10
0096:  DATA 20,10
0097:  DATA A0,12
0098:  DATA 30,19
0099:  DATA E4,17
009A:  DATA 25,18
009B:  DATA 32,32
009C:  DATA AF,12
009D:  DATA 30,19
009E:  DATA 64,05
009F:  DATA 00,10
00A0:  DATA 20,10
00A1:  DATA 20,10
00A2:  DATA A0,12
00A3:  DATA 30,19
00A4:  DATA 64,1D
00A5:  DATA 25,18
00A6:  DATA 32,32
00A7:  DATA BA,12
00A8:  DATA 30,19
00A9:  DATA 64,00
00AA:  DATA 8C,2C
00AB:  DATA F5,35
00AC:  DATA F3,32
00AD:  DATA 6B,10
00AE:  DATA C7,30
00AF:  DATA 7A,10
00B0:  DATA D3,32
00B1:  DATA F6,34
00B2:  DATA F9,32
00B3:  DATA F3,34
00B4:  DATA 0A,00
00B5:  DATA 21,10
00B6:  DATA A0,10
00B7:  DATA 20,10
00B8:  DATA 21,10
00B9:  DATA A0,10
00BA:  DATA 20,10
00BB:  DATA 21,10
00BC:  DATA A0,10
00BD:  DATA 20,10
00BE:  DATA 21,00
00BF:  DATA 8C,29
00C0:  DATA E9,31
00C1:  DATA E1,35
00C2:  DATA EC,34
00C3:  DATA 6B,14
00C4:  DATA 25,32
00C5:  DATA A0,21
00C6:  DATA 29,00
00C7:  DATA CE,37
00C8:  DATA F2,36
00C9:  DATA 61,36
00CA:  DATA 00,01
00CB:  DATA 8C,29
00CC:  DATA E9,31
00CD:  DATA E1,35
00CE:  DATA EC,34
00CF:  DATA 6B,14
00D0:  DATA 25,32
00D1:  DATA A0,21
00D2:  DATA 29,00
00D3:  DATA D9,3A
00D4:  DATA EB,39
00D5:  DATA 65,36
00D6:  DATA E9,3C
00D7:  DATA 6F,39
00D8:  DATA 00,01
00D9:  DATA 8C,29
00DA:  DATA E9,31
00DB:  DATA E1,35
00DC:  DATA EC,34
00DD:  DATA EB,2C
00DE:  DATA F5,35
00DF:  DATA F3,32
00E0:  DATA 6C,32
00E1:  DATA 69,10
00E2:  DATA 25,32
00E3:  DATA 43,00
00E4:  DATA C6,30
00E5:  DATA 6E,10
00E6:  DATA C1,35
00E7:  DATA F4,34
00E8:  DATA 66,00
00E9:  DATA 8C,20
00EA:  DATA F3,34
00EB:  DATA F2,34
00EC:  DATA 20,10
00ED:  DATA 20,14
00EE:  DATA 25,32
00EF:  DATA A0,21
00F0:  DATA 29,00
00F1:  DATA D3,34
00F2:  DATA E3,30
00F3:  DATA 6B,36
00F4:  DATA E9,35
00F5:  DATA 00,01
*
0197:  BSF    0A.0
0198:  BCF    0A.1
0199:  BCF    0A.2
019A:  ADDWF  02,F
019B:  GOTO   184
019C:  GOTO   187
019D:  GOTO   18A
019E:  GOTO   18D
*
01C6:  MOVF   0B,W
01C7:  MOVWF  44
01C8:  BCF    0B.7
01C9:  BSF    03.5
01CA:  BSF    03.6
01CB:  BSF    0C.7
01CC:  BSF    0C.0
01CD:  NOP
01CE:  NOP
01CF:  BCF    03.5
01D0:  MOVF   0C,W
01D1:  ANDLW  7F
01D2:  BTFSC  03.2
01D3:  GOTO   20D
01D4:  BCF    03.6
01D5:  MOVWF  45
01D6:  BSF    03.6
01D7:  MOVF   0D,W
01D8:  BCF    03.6
01D9:  MOVWF  46
01DA:  BSF    03.6
01DB:  MOVF   0F,W
01DC:  BCF    03.6
01DD:  MOVWF  47
01DE:  MOVF   45,W
01DF:  MOVWF  4D
01E0:  CALL   19F
01E1:  MOVF   46,W
01E2:  BSF    03.6
01E3:  MOVWF  0D
01E4:  BCF    03.6
01E5:  MOVF   47,W
01E6:  BSF    03.6
01E7:  MOVWF  0F
01E8:  BSF    03.5
01E9:  BSF    0C.7
01EA:  BSF    0C.0
01EB:  NOP
01EC:  NOP
01ED:  BCF    03.5
01EE:  RLF    0C,W
01EF:  RLF    0E,W
01F0:  ANDLW  7F
01F1:  BTFSC  03.2
01F2:  GOTO   20D
01F3:  BCF    03.6
01F4:  MOVWF  45
01F5:  BSF    03.6
01F6:  MOVF   0D,W
01F7:  BCF    03.6
01F8:  MOVWF  46
01F9:  BSF    03.6
01FA:  MOVF   0F,W
01FB:  BCF    03.6
01FC:  MOVWF  47
01FD:  MOVF   45,W
01FE:  MOVWF  4D
01FF:  CALL   19F
0200:  MOVF   46,W
0201:  BSF    03.6
0202:  MOVWF  0D
0203:  BCF    03.6
0204:  MOVF   47,W
0205:  BSF    03.6
0206:  MOVWF  0F
0207:  INCF   0D,F
0208:  BTFSC  03.2
0209:  INCF   0F,F
020A:  BCF    03.6
020B:  GOTO   1C9
020C:  BSF    03.6
020D:  BCF    03.6
020E:  BTFSC  44.7
020F:  BSF    0B.7
0210:  RETURN
*
029E:  CLRF   77
029F:  CLRF   78
02A0:  MOVF   4D,W
02A1:  BCF    03.0
02A2:  BTFSC  4E.0
02A3:  ADDWF  77,F
02A4:  RRF    77,F
02A5:  RRF    78,F
02A6:  BTFSC  4E.1
02A7:  ADDWF  77,F
02A8:  RRF    77,F
02A9:  RRF    78,F
02AA:  BTFSC  4E.2
02AB:  ADDWF  77,F
02AC:  RRF    77,F
02AD:  RRF    78,F
02AE:  BTFSC  4E.3
02AF:  ADDWF  77,F
02B0:  RRF    77,F
02B1:  RRF    78,F
02B2:  BTFSC  4E.4
02B3:  ADDWF  77,F
02B4:  RRF    77,F
02B5:  RRF    78,F
02B6:  BTFSC  4E.5
02B7:  ADDWF  77,F
02B8:  RRF    77,F
02B9:  RRF    78,F
02BA:  BTFSC  4E.6
02BB:  ADDWF  77,F
02BC:  RRF    77,F
02BD:  RRF    78,F
02BE:  BTFSC  4E.7
02BF:  ADDWF  77,F
02C0:  RRF    77,F
02C1:  RRF    78,F
*
033A:  MOVF   0B,W
033B:  MOVWF  47
033C:  BCF    0B.7
033D:  BSF    03.5
033E:  BSF    03.6
033F:  BSF    0C.7
0340:  BSF    0C.0
0341:  NOP
0342:  NOP
0343:  BTFSC  03.0
0344:  GOTO   36C
0345:  BCF    03.5
0346:  MOVF   0C,W
0347:  ANDLW  7F
0348:  BCF    03.6
0349:  MOVWF  48
034A:  BSF    03.6
034B:  MOVF   0D,W
034C:  BCF    03.6
034D:  MOVWF  49
034E:  BSF    03.6
034F:  MOVF   0F,W
0350:  BCF    03.6
0351:  MOVWF  4A
0352:  MOVF   48,W
0353:  MOVWF  4D
0354:  CALL   19F
0355:  MOVF   49,W
0356:  BSF    03.6
0357:  MOVWF  0D
0358:  BCF    03.6
0359:  MOVF   4A,W
035A:  BSF    03.6
035B:  MOVWF  0F
035C:  BSF    03.5
035D:  BSF    0C.7
035E:  BSF    0C.0
035F:  NOP
0360:  NOP
0361:  BCF    03.5
0362:  BCF    03.6
0363:  DECFSZ 46,F
0364:  GOTO   366
0365:  GOTO   369
0366:  BSF    03.5
0367:  BSF    03.6
0368:  GOTO   36C
0369:  GOTO   38B
036A:  BSF    03.5
036B:  BSF    03.6
036C:  BCF    03.5
036D:  RLF    0C,W
036E:  RLF    0E,W
036F:  ANDLW  7F
0370:  BCF    03.6
0371:  MOVWF  48
0372:  BSF    03.6
0373:  MOVF   0D,W
0374:  BCF    03.6
0375:  MOVWF  49
0376:  BSF    03.6
0377:  MOVF   0F,W
0378:  BCF    03.6
0379:  MOVWF  4A
037A:  MOVF   48,W
037B:  MOVWF  4D
037C:  CALL   19F
037D:  MOVF   49,W
037E:  BSF    03.6
037F:  MOVWF  0D
0380:  BCF    03.6
0381:  MOVF   4A,W
0382:  BSF    03.6
0383:  MOVWF  0F
0384:  INCF   0D,F
0385:  BTFSC  03.2
0386:  INCF   0F,F
0387:  BCF    03.0
0388:  BCF    03.6
0389:  DECFSZ 46,F
038A:  GOTO   33D
038B:  BTFSC  47.7
038C:  BSF    0B.7
038D:  RETURN
038E:  MOVF   4E,W
038F:  CLRF   78
0390:  SUBWF  4D,W
0391:  BTFSC  03.0
0392:  GOTO   396
0393:  MOVF   4D,W
0394:  MOVWF  77
0395:  GOTO   3A2
0396:  CLRF   77
0397:  MOVLW  08
0398:  MOVWF  4F
0399:  RLF    4D,F
039A:  RLF    77,F
039B:  MOVF   4E,W
039C:  SUBWF  77,W
039D:  BTFSC  03.0
039E:  MOVWF  77
039F:  RLF    78,F
03A0:  DECFSZ 4F,F
03A1:  GOTO   399
03A2:  RETURN
03A3:  MOVLW  20
03A4:  BTFSS  48.4
03A5:  MOVLW  30
03A6:  MOVWF  49
03A7:  MOVF   47,W
03A8:  MOVWF  77
03A9:  BTFSS  47.7
03AA:  GOTO   3B3
03AB:  COMF   77,F
03AC:  INCF   77,F
03AD:  MOVF   77,W
03AE:  MOVWF  47
03AF:  MOVLW  2D
03B0:  MOVWF  49
03B1:  BSF    48.7
03B2:  BSF    48.0
03B3:  MOVF   47,W
03B4:  MOVWF  4D
03B5:  MOVLW  64
03B6:  MOVWF  4E
03B7:  CALL   38E
03B8:  MOVF   77,W
03B9:  MOVWF  47
03BA:  MOVLW  30
03BB:  ADDWF  78,W
03BC:  MOVWF  4A
03BD:  MOVF   47,W
03BE:  MOVWF  4D
03BF:  MOVLW  0A
03C0:  MOVWF  4E
03C1:  CALL   38E
03C2:  MOVLW  30
03C3:  ADDWF  77,W
03C4:  MOVWF  4C
03C5:  MOVLW  30
03C6:  ADDWF  78,W
03C7:  MOVWF  4B
03C8:  MOVF   49,W
03C9:  MOVWF  77
03CA:  MOVLW  30
03CB:  SUBWF  4A,W
03CC:  BTFSC  03.2
03CD:  GOTO   3D2
03CE:  BSF    48.1
03CF:  BTFSC  48.7
03D0:  BSF    48.2
03D1:  GOTO   3E6
03D2:  MOVF   49,W
03D3:  MOVWF  4A
03D4:  MOVLW  20
03D5:  MOVWF  49
03D6:  MOVLW  30
03D7:  SUBWF  4B,W
03D8:  BTFSC  03.2
03D9:  GOTO   3DE
03DA:  BSF    48.0
03DB:  BTFSC  48.7
03DC:  BSF    48.1
03DD:  GOTO   3E6
03DE:  BTFSS  03.2
03DF:  BSF    48.0
03E0:  BTFSS  03.2
03E1:  GOTO   3E6
03E2:  MOVF   4A,W
03E3:  MOVWF  4B
03E4:  MOVLW  20
03E5:  MOVWF  4A
03E6:  BTFSC  48.2
03E7:  GOTO   3ED
03E8:  BTFSC  48.1
03E9:  GOTO   3F0
03EA:  BTFSC  48.0
03EB:  GOTO   3F3
03EC:  GOTO   3F6
03ED:  MOVF   49,W
03EE:  MOVWF  4D
03EF:  CALL   19F
03F0:  MOVF   4A,W
03F1:  MOVWF  4D
03F2:  CALL   19F
03F3:  MOVF   4B,W
03F4:  MOVWF  4D
03F5:  CALL   19F
03F6:  MOVF   4C,W
03F7:  MOVWF  4D
03F8:  CALL   19F
03F9:  RETURN
03FA:  MOVLW  20
03FB:  BTFSS  45.4
03FC:  MOVLW  30
03FD:  MOVWF  46
03FE:  MOVF   44,W
03FF:  MOVWF  77
0400:  BTFSS  44.7
0401:  GOTO   40A
0402:  COMF   77,F
0403:  INCF   77,F
0404:  MOVF   77,W
0405:  MOVWF  44
0406:  MOVLW  2D
0407:  MOVWF  46
0408:  BSF    45.7
0409:  BSF    45.0
040A:  MOVF   44,W
040B:  MOVWF  4D
040C:  MOVLW  64
040D:  MOVWF  4E
040E:  CALL   38E
040F:  MOVF   77,W
0410:  MOVWF  44
0411:  MOVLW  30
0412:  ADDWF  78,W
0413:  MOVWF  47
0414:  MOVF   44,W
0415:  MOVWF  4D
0416:  MOVLW  0A
0417:  MOVWF  4E
0418:  CALL   38E
0419:  MOVLW  30
041A:  ADDWF  77,W
041B:  MOVWF  49
041C:  MOVLW  30
041D:  ADDWF  78,W
041E:  MOVWF  48
041F:  MOVF   46,W
0420:  MOVWF  77
0421:  MOVLW  30
0422:  SUBWF  47,W
0423:  BTFSC  03.2
0424:  GOTO   429
0425:  BSF    45.1
0426:  BTFSC  45.7
0427:  BSF    45.2
0428:  GOTO   43D
0429:  BTFSC  45.2
042A:  GOTO   43D
042B:  MOVF   46,W
042C:  MOVWF  47
042D:  BTFSC  45.1
042E:  GOTO   434
042F:  MOVLW  30
0430:  SUBWF  48,W
0431:  BTFSC  03.2
0432:  GOTO   437
0433:  BSF    45.0
0434:  BTFSC  45.7
0435:  BSF    45.1
0436:  GOTO   43D
0437:  BTFSS  03.2
0438:  BSF    45.0
0439:  BTFSS  03.2
043A:  GOTO   43D
043B:  MOVF   47,W
043C:  MOVWF  48
043D:  BTFSC  45.2
043E:  GOTO   444
043F:  BTFSC  45.1
0440:  GOTO   447
0441:  BTFSC  45.0
0442:  GOTO   44A
0443:  GOTO   44D
0444:  MOVF   46,W
0445:  MOVWF  4D
0446:  CALL   19F
0447:  MOVF   47,W
0448:  MOVWF  4D
0449:  CALL   19F
044A:  MOVF   48,W
044B:  MOVWF  4D
044C:  CALL   19F
044D:  MOVF   49,W
044E:  MOVWF  4D
044F:  CALL   19F
0450:  RETURN
*
0FAB:  BSF    0A.0
0FAC:  BSF    0A.1
0FAD:  BSF    0A.2
0FAE:  ADDWF  02,F
0FAF:  GOTO   0FE
0FB0:  GOTO   115
0FB1:  GOTO   12C
0FB2:  GOTO   143
0FB3:  GOTO   15A
0FB4:  GOTO   171
0FB5:  GOTO   188
....................  
.................... #list 
....................  
.................... #define ADC = 10 
.................... #fuses XT,NOWDT,NOPROTECT,NOBROWNOUT,NOLVP,NOPUT,NOWRT,NODEBUG,NOCPD 
.................... #use delay(clock=4M) 
*
00F6:  MOVLW  4E
00F7:  MOVWF  04
00F8:  BCF    03.7
00F9:  MOVF   00,W
00FA:  BTFSC  03.2
00FB:  GOTO   10A
00FC:  MOVLW  01
00FD:  MOVWF  78
00FE:  CLRF   77
00FF:  DECFSZ 77,F
0100:  GOTO   0FF
0101:  DECFSZ 78,F
0102:  GOTO   0FE
0103:  MOVLW  4A
0104:  MOVWF  77
0105:  DECFSZ 77,F
0106:  GOTO   105
0107:  GOTO   108
0108:  DECFSZ 00,F
0109:  GOTO   0FC
010A:  RETURN
.................... #use fast_io(A) 
....................  
....................  
.................... #define use_portb_lcd TRUE   // LCD B portuna baðlý 
.................... //***DS1302 ÝÇÝN PIN TANIMLAMALARI***// 
.................... #define RTC_SCLK PIN_C3     
.................... #define RTC_IO PIN_D6 
.................... #define RTC_RST PIN_D4 
....................  
....................  
.................... #include "lcd420.c" 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////                             LCD420.C                               //// 
.................... ////            Driver for common 4x20 LCD modules                      //// 
.................... ////                                                                    //// 
.................... ////  lcd_init()   Must be called before any other function.            //// 
.................... ////                                                                    //// 
.................... ////  lcd_putc(c)  Will display c on the next position of the LCD.      //// 
.................... ////                     The following have special meaning:            //// 
.................... ////                      \f  Clear display                             //// 
.................... ////                      \n  Go to start of second line                //// 
.................... ////                      \b  Move back one position                    //// 
.................... ////                                                                    //// 
.................... ////  lcd_gotoxy(x,y) Set write position on LCD (upper left is 1,1)     //// 
.................... ////                                                                    //// 
.................... ////  lcd_getc(x,y)   Returns character at position x,y on LCD          //// 
.................... ////                                                                    //// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,1997 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... // As defined in the following structure the pin connection is as follows: 
.................... //     B0  enable 
.................... //     B1  rs 
.................... //     B2  rw 
.................... //     B4  D4 
.................... //     B5  D5 
.................... //     B6  D6 
.................... //     B7  D7 
.................... // 
.................... //   LCD pins D0-D3 are not used and PIC B3 is not used. 
....................  
.................... struct lcd_pin_map {                 // This structure is overlayed 
....................            BOOLEAN enable;           // on to an I/O port to gain 
....................            BOOLEAN rs;               // access to the LCD pins. 
....................            BOOLEAN rw;               // The bits are allocated from 
....................            BOOLEAN unused;           // low order up.  ENABLE will 
....................            int     data : 4;         // be pin B0. 
....................         } lcd; 
....................  
.................... #locate lcd = getenv("SFR:PORTB")                        // This puts the entire structure 
....................                                      // on to port B  
....................  
.................... #define lcd_type 2           // 0=5x7, 1=5x10, 2=2 lines 
....................  
....................  
.................... BYTE const LCD_INIT_STRING[4] = {0x20 | (lcd_type << 2), 0xc, 1, 6}; 
....................                              // These bytes need to be sent to the LCD 
....................                              // to start it up. 
....................  
....................  
....................                              // The following are used for setting 
....................                              // the I/O port direction register. 
....................  
.................... struct lcd_pin_map const LCD_WRITE = {0,0,0,0,0}; // For write mode all pins are out 
.................... struct lcd_pin_map const LCD_READ = {0,0,0,0,15}; // For read mode data pins are in 
....................  
....................  
.................... BYTE lcdline; 
....................  
.................... BYTE lcd_read_byte() { 
....................       BYTE low,high; 
....................  
....................       set_tris_b(LCD_READ); 
*
0118:  MOVLW  F0
0119:  BSF    03.5
011A:  MOVWF  06
....................       lcd.rw = 1; 
011B:  BCF    03.5
011C:  BSF    06.2
....................       delay_cycles(1); 
011D:  NOP
....................       lcd.enable = 1; 
011E:  BSF    06.0
....................       delay_cycles(1); 
011F:  NOP
....................       high = lcd.data; 
0120:  MOVF   06,W
0121:  SWAPF  06,W
0122:  ANDLW  0F
0123:  MOVWF  54
....................       lcd.enable = 0; 
0124:  BCF    06.0
....................       delay_cycles(1); 
0125:  NOP
....................       lcd.enable = 1; 
0126:  BSF    06.0
....................       delay_us(1); 
0127:  NOP
....................       low = lcd.data; 
0128:  MOVF   06,W
0129:  SWAPF  06,W
012A:  ANDLW  0F
012B:  MOVWF  53
....................       lcd.enable = 0; 
012C:  BCF    06.0
....................       set_tris_b(LCD_WRITE); 
012D:  MOVLW  00
012E:  BSF    03.5
012F:  MOVWF  06
....................       return( (high<<4) | low); 
0130:  BCF    03.5
0131:  SWAPF  54,W
0132:  MOVWF  77
0133:  MOVLW  F0
0134:  ANDWF  77,F
0135:  MOVF   77,W
0136:  IORWF  53,W
0137:  MOVWF  78
.................... } 
....................  
....................  
.................... void lcd_send_nibble( BYTE n ) { 
....................       lcd.data = n; 
*
010B:  SWAPF  54,W
010C:  ANDLW  F0
010D:  MOVWF  77
010E:  MOVLW  0F
010F:  ANDWF  06,W
0110:  IORWF  77,W
0111:  MOVWF  06
....................       delay_cycles(1); 
0112:  NOP
....................       lcd.enable = 1; 
0113:  BSF    06.0
....................       delay_us(2); 
0114:  GOTO   115
....................       lcd.enable = 0; 
0115:  BCF    06.0
0116:  RETURN
.................... } 
....................  
....................  
.................... void lcd_send_byte( BYTE address, BYTE n ) { 
....................  
....................       lcd.rs = 0; 
0117:  BCF    06.1
....................       while ( bit_test(lcd_read_byte(),7) ) ; 
*
0138:  MOVF   78,W
0139:  MOVWF  53
013A:  BTFSC  53.7
013B:  GOTO   118
....................       lcd.rs = address; 
013C:  BTFSS  51.0
013D:  BCF    06.1
013E:  BTFSC  51.0
013F:  BSF    06.1
....................       delay_cycles(1); 
0140:  NOP
....................       lcd.rw = 0; 
0141:  BCF    06.2
....................       delay_cycles(1); 
0142:  NOP
....................       lcd.enable = 0; 
0143:  BCF    06.0
....................       lcd_send_nibble(n >> 4); 
0144:  SWAPF  52,W
0145:  MOVWF  53
0146:  MOVLW  0F
0147:  ANDWF  53,F
0148:  MOVF   53,W
0149:  MOVWF  54
014A:  CALL   10B
....................       lcd_send_nibble(n & 0xf); 
014B:  MOVF   52,W
014C:  ANDLW  0F
014D:  MOVWF  53
014E:  MOVWF  54
014F:  CALL   10B
0150:  RETURN
.................... } 
....................  
....................  
.................... void lcd_init() { 
....................     BYTE i; 
....................  
....................     set_tris_b(LCD_WRITE); 
0151:  MOVLW  00
0152:  BSF    03.5
0153:  MOVWF  06
....................     lcd.rs = 0; 
0154:  BCF    03.5
0155:  BCF    06.1
....................     lcd.rw = 0; 
0156:  BCF    06.2
....................     lcd.enable = 0; 
0157:  BCF    06.0
....................     delay_ms(15); 
0158:  MOVLW  0F
0159:  MOVWF  4E
015A:  CALL   0F6
....................     for(i=1;i<=3;++i) { 
015B:  MOVLW  01
015C:  MOVWF  44
015D:  MOVF   44,W
015E:  SUBLW  03
015F:  BTFSS  03.0
0160:  GOTO   169
....................        lcd_send_nibble(3); 
0161:  MOVLW  03
0162:  MOVWF  54
0163:  CALL   10B
....................        delay_ms(5); 
0164:  MOVLW  05
0165:  MOVWF  4E
0166:  CALL   0F6
0167:  INCF   44,F
0168:  GOTO   15D
....................     } 
....................     lcd_send_nibble(2); 
0169:  MOVLW  02
016A:  MOVWF  54
016B:  CALL   10B
....................     for(i=0;i<=3;++i) 
016C:  CLRF   44
016D:  MOVF   44,W
016E:  SUBLW  03
016F:  BTFSS  03.0
0170:  GOTO   17A
....................        lcd_send_byte(0, LCD_INIT_STRING[i]); 
0171:  MOVF   44,W
0172:  CALL   038
0173:  MOVWF  45
0174:  CLRF   51
0175:  MOVF   45,W
0176:  MOVWF  52
0177:  CALL   117
0178:  INCF   44,F
0179:  GOTO   16D
017A:  BSF    0A.3
017B:  BCF    0A.4
017C:  GOTO   013 (RETURN)
.................... } 
....................  
....................  
.................... void lcd_gotoxy( BYTE x, BYTE y) { 
....................    BYTE address; 
....................  
....................    switch(y) { 
017D:  MOVLW  01
017E:  SUBWF  4F,W
017F:  ADDLW  FC
0180:  BTFSC  03.0
0181:  GOTO   18F
0182:  ADDLW  04
0183:  GOTO   197
....................      case 1 : address=0x80;break; 
0184:  MOVLW  80
0185:  MOVWF  50
0186:  GOTO   18F
....................      case 2 : address=0xc0;break; 
0187:  MOVLW  C0
0188:  MOVWF  50
0189:  GOTO   18F
....................      case 3 : address=0x94;break; 
018A:  MOVLW  94
018B:  MOVWF  50
018C:  GOTO   18F
....................      case 4 : address=0xd4;break; 
018D:  MOVLW  D4
018E:  MOVWF  50
....................    } 
....................    address+=x-1; 
018F:  MOVLW  01
0190:  SUBWF  4E,W
0191:  ADDWF  50,F
....................    lcd_send_byte(0,address); 
0192:  CLRF   51
0193:  MOVF   50,W
0194:  MOVWF  52
0195:  CALL   117
0196:  RETURN
.................... } 
....................  
.................... void lcd_putc( char c) { 
....................    switch (c) { 
*
019F:  MOVF   4D,W
01A0:  XORLW  0C
01A1:  BTFSC  03.2
01A2:  GOTO   1AA
01A3:  XORLW  06
01A4:  BTFSC  03.2
01A5:  GOTO   1B4
01A6:  XORLW  02
01A7:  BTFSC  03.2
01A8:  GOTO   1BB
01A9:  GOTO   1C0
....................      case '\f'   : lcd_send_byte(0,1); 
01AA:  CLRF   51
01AB:  MOVLW  01
01AC:  MOVWF  52
01AD:  CALL   117
....................                    lcdline=1; 
01AE:  MOVLW  01
01AF:  MOVWF  27
....................                    delay_ms(2); 
01B0:  MOVLW  02
01B1:  MOVWF  4E
01B2:  CALL   0F6
....................                                            break; 
01B3:  GOTO   1C5
....................      case '\n'   : lcd_gotoxy(1,++lcdline);        break; 
01B4:  INCF   27,F
01B5:  MOVLW  01
01B6:  MOVWF  4E
01B7:  MOVF   27,W
01B8:  MOVWF  4F
01B9:  CALL   17D
01BA:  GOTO   1C5
....................      case '\b'   : lcd_send_byte(0,0x10);  break; 
01BB:  CLRF   51
01BC:  MOVLW  10
01BD:  MOVWF  52
01BE:  CALL   117
01BF:  GOTO   1C5
....................      default     : lcd_send_byte(1,c);     break; 
01C0:  MOVLW  01
01C1:  MOVWF  51
01C2:  MOVF   4D,W
01C3:  MOVWF  52
01C4:  CALL   117
....................    } 
01C5:  RETURN
.................... } 
....................  
.................... char lcd_getc( BYTE x, BYTE y) { 
....................    char value; 
....................  
....................     lcd_gotoxy(x,y); 
....................     lcd.rs=1; 
....................     value = lcd_read_byte(); 
....................     lcd.rs=0; 
....................     return(value); 
.................... } 
....................  
....................  
.................... #include "stdlib.h" 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
*
080E:  BCF    03.5
080F:  CLRF   28
0810:  CLRF   29
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... static char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strupr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include "dht-11.c" //dht-11 dosyasý tanýtýlýyor. 
.................... #ifndef dht11 
....................  
....................    #define dht11 PIN_A1 
....................  
.................... #endif 
....................  
....................  
....................  
.................... char dht_dat[10]; // Output data will be here 
....................  
....................  
....................  
.................... void dht_init() 
....................  
....................  
....................  
.................... { 
....................  
....................     delay_ms (1); 
*
02D2:  MOVLW  01
02D3:  MOVWF  4E
02D4:  CALL   0F6
....................  
....................     OUTPUT_HIGH (dht11); 
02D5:  BSF    05.1
....................  
.................... } 
....................  
.................... byte leer_dht_dat() 
*
030B:  CLRF   4A
030C:  CLRF   4B
....................  
....................  
....................  
.................... { 
....................  
....................     byte i = 0; 
....................  
....................     byte result = 0; 
....................  
....................  
....................  
....................     for (i = 0; i < 8; i++) 
030D:  CLRF   4A
030E:  MOVF   4A,W
030F:  SUBLW  07
0310:  BTFSS  03.0
0311:  GOTO   32D
....................  
....................     { 
....................  
....................         while (input (dht11) == 0) 
0312:  BTFSS  05.1
0313:  GOTO   312
....................  
....................             ; 
....................  
....................  
....................  
....................         delay_us (30); 
0314:  MOVLW  09
0315:  MOVWF  77
0316:  DECFSZ 77,F
0317:  GOTO   316
0318:  GOTO   319
....................  
....................  
....................  
....................         if (input (dht11) == 1) 
0319:  BTFSS  05.1
031A:  GOTO   329
....................  
....................         { 
....................  
....................             result |= (1 << (7 - i) ); 
031B:  MOVF   4A,W
031C:  SUBLW  07
031D:  MOVWF  78
031E:  MOVLW  01
031F:  MOVWF  77
0320:  MOVF   78,F
0321:  BTFSC  03.2
0322:  GOTO   327
0323:  BCF    03.0
0324:  RLF    77,F
0325:  DECFSZ 78,F
0326:  GOTO   323
0327:  MOVF   77,W
0328:  IORWF  4B,F
....................  
....................         } 
....................  
....................  
....................  
....................         while (input (dht11) == 1) 
0329:  BTFSC  05.1
032A:  GOTO   329
....................  
....................             ; 
032B:  INCF   4A,F
032C:  GOTO   30E
....................  
....................     } 
....................  
....................  
....................  
....................     return result; 
032D:  MOVF   4B,W
032E:  MOVWF  78
....................  
.................... } 
....................  
....................  
....................  
.................... void read_dht() 
*
02D1:  CLRF   44
....................  
....................  
....................  
.................... { 
....................  
....................     byte GlobalErr = 0; 
....................  
....................     byte dht_in; 
....................  
....................     byte i; 
....................  
....................     byte dht_check_sum; 
....................  
....................     dht_init(); 
....................  
....................     OUTPUT_LOW (dht11); 
*
02D6:  BCF    05.1
....................  
....................     delay_ms (18); 
02D7:  MOVLW  12
02D8:  MOVWF  4E
02D9:  CALL   0F6
....................  
....................     OUTPUT_HIGH (dht11); 
02DA:  BSF    05.1
....................  
....................     delay_us (30); 
02DB:  MOVLW  09
02DC:  MOVWF  77
02DD:  DECFSZ 77,F
02DE:  GOTO   2DD
02DF:  GOTO   2E0
....................  
....................     dht_in = input (dht11); 
02E0:  CLRF   45
02E1:  BTFSC  05.1
02E2:  INCF   45,F
....................  
....................  
....................  
....................     if (dht_in) 
02E3:  MOVF   45,F
02E4:  BTFSC  03.2
02E5:  GOTO   2E9
....................  
....................     { 
....................  
....................         GlobalErr = 1; 
02E6:  MOVLW  01
02E7:  MOVWF  44
....................  
....................         return; 
02E8:  GOTO   339
....................  
....................     } 
....................  
....................  
....................  
....................     delay_us (80); 
02E9:  MOVLW  1A
02EA:  MOVWF  77
02EB:  DECFSZ 77,F
02EC:  GOTO   2EB
02ED:  NOP
....................  
....................     dht_in = input (dht11); 
02EE:  CLRF   45
02EF:  BTFSC  05.1
02F0:  INCF   45,F
....................  
....................  
....................  
....................     if (!dht_in) 
02F1:  MOVF   45,F
02F2:  BTFSS  03.2
02F3:  GOTO   2F7
....................  
....................     { 
....................  
....................         GlobalErr = 2; 
02F4:  MOVLW  02
02F5:  MOVWF  44
....................  
....................         return; 
02F6:  GOTO   339
....................  
....................     } 
....................  
....................  
....................  
....................     delay_us (80); 
02F7:  MOVLW  1A
02F8:  MOVWF  77
02F9:  DECFSZ 77,F
02FA:  GOTO   2F9
02FB:  NOP
....................  
....................  
....................  
....................     for (i = 0; i < 4; i++) 
02FC:  CLRF   46
02FD:  MOVF   46,W
02FE:  SUBLW  03
02FF:  BTFSS  03.0
0300:  GOTO   338
....................  
....................     { 
....................  
....................         dht_dat[i] = leer_dht_dat(); 
0301:  MOVLW  2E
0302:  ADDWF  46,W
0303:  MOVWF  78
0304:  CLRF   7A
0305:  BTFSC  03.0
0306:  INCF   7A,F
0307:  MOVF   78,W
0308:  MOVWF  48
0309:  MOVF   7A,W
030A:  MOVWF  49
*
032F:  MOVF   48,W
0330:  MOVWF  04
0331:  BCF    03.7
0332:  BTFSC  49.0
0333:  BSF    03.7
0334:  MOVF   78,W
0335:  MOVWF  00
0336:  INCF   46,F
0337:  GOTO   2FD
....................  
....................     } 
....................  
....................  
....................  
....................     OUTPUT_HIGH (dht11); 
0338:  BSF    05.1
0339:  RETURN
....................  
.................... } 
....................  
....................  
....................  
.................... #include "ds1302.c"  //DS1302 AÝT FONKSÝYONLAR PROGRAMA EKLENÝR 
.................... ////////////////////////////////////////////////////////////////////////// 
.................... ////                               DS1302.C                           //// 
.................... ////                     Driver for Real Time Clock                   //// 
.................... ////                                                                  //// 
.................... ////  rtc_init()                                   Call after power up//// 
.................... ////                                                                  //// 
.................... ////  rtc_set_datetime(day,mth,year,dow,hour,min)  Set the date/time  //// 
.................... ////                                                                  //// 
.................... ////  rtc_get_date(day,mth,year,dow)               Get the date       //// 
.................... ////                                                                  //// 
.................... ////  rtc_get_time(hr,min,sec)                     Get the time       //// 
.................... ////                                                                  //// 
.................... ////  rtc_write_nvr(address,data)                  Write to NVR       //// 
.................... ////                                                                  //// 
.................... ////  data = rtc_read_nvr(address)                 Read from NVR      //// 
.................... ////                                                                  //// 
.................... ////  get_bcd(data)                              Convert data to BCD  //// 
.................... ////                                                                  //// 
.................... ////  rm_bcd(data)                               Convert data to int  //// 
.................... ////                                                                  //// 
.................... ////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C //// 
.................... //// compiler.  This source code may only be distributed to other     //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction//// 
.................... //// or distribution is permitted without written permission.         //// 
.................... //// Derivative programs created using this software in object code   //// 
.................... //// form are not restricted in any way.                              //// 
.................... ////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef RTC_SCLK 
....................  
.................... #define RTC_SCLK PIN_C3 
.................... #define RTC_IO   PIN_D6 
.................... #define RTC_RST  PIN_D4 
....................  
.................... #endif 
....................  
.................... void write_ds1302_byte(BYTE cmd) { 
....................    BYTE i; 
....................  
....................    for(i=0;i<=7;++i) { 
*
0211:  CLRF   4C
0212:  MOVF   4C,W
0213:  SUBLW  07
0214:  BTFSS  03.0
0215:  GOTO   22E
....................       output_bit(RTC_IO, shift_right(&cmd,1,0) ); 
0216:  BCF    03.0
0217:  RRF    4B,F
0218:  BTFSC  03.0
0219:  GOTO   21C
021A:  BCF    08.6
021B:  GOTO   21D
021C:  BSF    08.6
021D:  BSF    03.5
021E:  BCF    08.6
....................       output_high(RTC_SCLK); 
021F:  BCF    03.5
0220:  BCF    38.3
0221:  MOVF   38,W
0222:  BSF    03.5
0223:  MOVWF  07
0224:  BCF    03.5
0225:  BSF    07.3
....................       output_low(RTC_SCLK); 
0226:  BCF    38.3
0227:  MOVF   38,W
0228:  BSF    03.5
0229:  MOVWF  07
022A:  BCF    03.5
022B:  BCF    07.3
022C:  INCF   4C,F
022D:  GOTO   212
....................    } 
022E:  RETURN
.................... } 
....................  
.................... void write_ds1302(BYTE cmd, BYTE data) { 
....................  
....................    output_high(RTC_RST); 
022F:  BSF    03.5
0230:  BCF    08.4
0231:  BCF    03.5
0232:  BSF    08.4
....................    write_ds1302_byte(cmd); 
0233:  MOVF   45,W
0234:  MOVWF  4B
0235:  CALL   211
....................    write_ds1302_byte(data); 
0236:  MOVF   46,W
0237:  MOVWF  4B
0238:  CALL   211
....................    output_low(RTC_RST); 
0239:  BSF    03.5
023A:  BCF    08.4
023B:  BCF    03.5
023C:  BCF    08.4
023D:  RETURN
.................... } 
....................  
.................... BYTE read_ds1302(BYTE cmd) { 
....................    BYTE i,data; 
....................  
....................    output_high(RTC_RST); 
023E:  BSF    03.5
023F:  BCF    08.4
0240:  BCF    03.5
0241:  BSF    08.4
....................    write_ds1302_byte(cmd); 
0242:  MOVF   48,W
0243:  MOVWF  4B
0244:  CALL   211
....................     
....................    input(RTC_IO); 
0245:  BSF    03.5
0246:  BSF    08.6
....................    delay_us(1); 
0247:  NOP
....................           
....................    for(i=0;i<=7;++i) { 
0248:  BCF    03.5
0249:  CLRF   49
024A:  MOVF   49,W
024B:  SUBLW  07
024C:  BTFSS  03.0
024D:  GOTO   267
....................       shift_right(&data,1,input(RTC_IO)); 
024E:  BSF    03.5
024F:  BSF    08.6
0250:  BCF    03.5
0251:  BTFSC  08.6
0252:  GOTO   255
0253:  BCF    03.0
0254:  GOTO   256
0255:  BSF    03.0
0256:  RRF    4A,F
....................       output_high(RTC_SCLK); 
0257:  BCF    38.3
0258:  MOVF   38,W
0259:  BSF    03.5
025A:  MOVWF  07
025B:  BCF    03.5
025C:  BSF    07.3
....................       delay_us(2); 
025D:  GOTO   25E
....................       output_low(RTC_SCLK); 
025E:  BCF    38.3
025F:  MOVF   38,W
0260:  BSF    03.5
0261:  MOVWF  07
0262:  BCF    03.5
0263:  BCF    07.3
....................       delay_us(2); 
0264:  GOTO   265
0265:  INCF   49,F
0266:  GOTO   24A
....................    } 
....................    output_low(RTC_RST); 
0267:  BSF    03.5
0268:  BCF    08.4
0269:  BCF    03.5
026A:  BCF    08.4
....................  
....................    return(data); 
026B:  MOVF   4A,W
026C:  MOVWF  78
026D:  RETURN
.................... } 
....................  
.................... void rtc_init() { 
....................    BYTE x; 
....................    output_low(RTC_RST); 
026E:  BSF    03.5
026F:  BCF    08.4
0270:  BCF    03.5
0271:  BCF    08.4
....................    delay_us(2); 
0272:  GOTO   273
....................    output_low(RTC_SCLK); 
0273:  BCF    38.3
0274:  MOVF   38,W
0275:  BSF    03.5
0276:  MOVWF  07
0277:  BCF    03.5
0278:  BCF    07.3
....................    write_ds1302(0x8e,0); 
0279:  MOVLW  8E
027A:  MOVWF  45
027B:  CLRF   46
027C:  CALL   22F
....................    write_ds1302(0x90,0xa4); 
027D:  MOVLW  90
027E:  MOVWF  45
027F:  MOVLW  A4
0280:  MOVWF  46
0281:  CALL   22F
....................    x=read_ds1302(0x81); 
0282:  MOVLW  81
0283:  MOVWF  48
0284:  CALL   23E
0285:  MOVF   78,W
0286:  MOVWF  44
....................    if((x & 0x80)!=0) 
0287:  MOVF   44,W
0288:  ANDLW  80
0289:  BTFSC  03.2
028A:  GOTO   28F
....................      write_ds1302(0x80,0); 
028B:  MOVLW  80
028C:  MOVWF  45
028D:  CLRF   46
028E:  CALL   22F
028F:  BSF    0A.3
0290:  BCF    0A.4
0291:  GOTO   094 (RETURN)
.................... } 
....................  
.................... byte get_bcd(BYTE data) 
.................... { 
....................    byte nibh; 
....................    byte nibl; 
....................  
....................    nibh=data/10; 
....................    nibl=data-(nibh*10); 
....................  
....................    return((nibh<<4)|nibl); 
.................... } 
....................  
.................... byte rm_bcd(BYTE data) 
.................... { 
....................    byte i; 
....................  
....................    i=data; 
0292:  MOVF   49,W
0293:  MOVWF  4A
....................    data=(i>>4)*10; 
0294:  SWAPF  4A,W
0295:  MOVWF  77
0296:  MOVLW  0F
0297:  ANDWF  77,F
0298:  MOVF   77,W
0299:  MOVWF  4C
029A:  MOVF   4C,W
029B:  MOVWF  4D
029C:  MOVLW  0A
029D:  MOVWF  4E
*
02C2:  MOVF   78,W
02C3:  MOVWF  49
....................    data=data+(i<<4>>4); 
02C4:  SWAPF  4A,W
02C5:  MOVWF  77
02C6:  MOVLW  F0
02C7:  ANDWF  77,F
02C8:  MOVF   77,W
02C9:  SWAPF  77,F
02CA:  MOVLW  0F
02CB:  ANDWF  77,F
02CC:  MOVF   77,W
02CD:  ADDWF  49,F
....................  
....................    return data; 
02CE:  MOVF   49,W
02CF:  MOVWF  78
02D0:  RETURN
.................... } 
....................  
.................... void rtc_set_datetime(BYTE day, BYTE mth, BYTE year, BYTE dow, BYTE hr, BYTE min) { 
....................  
....................    write_ds1302(0x86,get_bcd(day)); 
....................    write_ds1302(0x88,get_bcd(mth)); 
....................    write_ds1302(0x8c,get_bcd(year)); 
....................    write_ds1302(0x8a,get_bcd(dow)); 
....................    write_ds1302(0x84,get_bcd(hr)); 
....................    write_ds1302(0x82,get_bcd(min)); 
....................    write_ds1302(0x80,get_bcd(0)); 
.................... } 
....................  
.................... void rtc_get_date(BYTE& day, BYTE& mth, BYTE& year, BYTE& dow) { 
....................    day = rm_bcd(read_ds1302(0x87)); 
*
08BC:  MOVLW  87
08BD:  MOVWF  48
08BE:  BCF    0A.3
08BF:  CALL   23E
08C0:  BSF    0A.3
08C1:  MOVF   78,W
08C2:  MOVWF  44
08C3:  MOVWF  49
08C4:  BCF    0A.3
08C5:  CALL   292
08C6:  BSF    0A.3
08C7:  MOVF   78,W
08C8:  MOVWF  3E
*
0BC1:  MOVLW  87
0BC2:  MOVWF  48
0BC3:  BCF    0A.3
0BC4:  CALL   23E
0BC5:  BSF    0A.3
0BC6:  MOVF   78,W
0BC7:  MOVWF  44
0BC8:  MOVWF  49
0BC9:  BCF    0A.3
0BCA:  CALL   292
0BCB:  BSF    0A.3
0BCC:  MOVF   78,W
0BCD:  MOVWF  3E
....................    mth = rm_bcd(read_ds1302(0x89)); 
*
08C9:  MOVLW  89
08CA:  MOVWF  48
08CB:  BCF    0A.3
08CC:  CALL   23E
08CD:  BSF    0A.3
08CE:  MOVF   78,W
08CF:  MOVWF  44
08D0:  MOVWF  49
08D1:  BCF    0A.3
08D2:  CALL   292
08D3:  BSF    0A.3
08D4:  MOVF   78,W
08D5:  MOVWF  3F
*
0BCE:  MOVLW  89
0BCF:  MOVWF  48
0BD0:  BCF    0A.3
0BD1:  CALL   23E
0BD2:  BSF    0A.3
0BD3:  MOVF   78,W
0BD4:  MOVWF  44
0BD5:  MOVWF  49
0BD6:  BCF    0A.3
0BD7:  CALL   292
0BD8:  BSF    0A.3
0BD9:  MOVF   78,W
0BDA:  MOVWF  3F
....................    year = rm_bcd(read_ds1302(0x8d)); 
*
08D6:  MOVLW  8D
08D7:  MOVWF  48
08D8:  BCF    0A.3
08D9:  CALL   23E
08DA:  BSF    0A.3
08DB:  MOVF   78,W
08DC:  MOVWF  44
08DD:  MOVWF  49
08DE:  BCF    0A.3
08DF:  CALL   292
08E0:  BSF    0A.3
08E1:  MOVF   78,W
08E2:  MOVWF  40
*
0BDB:  MOVLW  8D
0BDC:  MOVWF  48
0BDD:  BCF    0A.3
0BDE:  CALL   23E
0BDF:  BSF    0A.3
0BE0:  MOVF   78,W
0BE1:  MOVWF  44
0BE2:  MOVWF  49
0BE3:  BCF    0A.3
0BE4:  CALL   292
0BE5:  BSF    0A.3
0BE6:  MOVF   78,W
0BE7:  MOVWF  40
....................    dow = rm_bcd(read_ds1302(0x8b)); 
*
08E3:  MOVLW  8B
08E4:  MOVWF  48
08E5:  BCF    0A.3
08E6:  CALL   23E
08E7:  BSF    0A.3
08E8:  MOVF   78,W
08E9:  MOVWF  44
08EA:  MOVWF  49
08EB:  BCF    0A.3
08EC:  CALL   292
08ED:  BSF    0A.3
08EE:  MOVF   78,W
08EF:  MOVWF  41
*
0BE8:  MOVLW  8B
0BE9:  MOVWF  48
0BEA:  BCF    0A.3
0BEB:  CALL   23E
0BEC:  BSF    0A.3
0BED:  MOVF   78,W
0BEE:  MOVWF  44
0BEF:  MOVWF  49
0BF0:  BCF    0A.3
0BF1:  CALL   292
0BF2:  BSF    0A.3
0BF3:  MOVF   78,W
0BF4:  MOVWF  41
.................... } 
....................  
.................... void rtc_get_time(BYTE& hr, BYTE& min, BYTE& sec) { 
....................    hr = rm_bcd(read_ds1302(0x85)); 
*
0895:  MOVLW  85
0896:  MOVWF  48
0897:  BCF    0A.3
0898:  CALL   23E
0899:  BSF    0A.3
089A:  MOVF   78,W
089B:  MOVWF  44
089C:  MOVWF  49
089D:  BCF    0A.3
089E:  CALL   292
089F:  BSF    0A.3
08A0:  MOVF   78,W
08A1:  MOVWF  3D
*
0B9A:  MOVLW  85
0B9B:  MOVWF  48
0B9C:  BCF    0A.3
0B9D:  CALL   23E
0B9E:  BSF    0A.3
0B9F:  MOVF   78,W
0BA0:  MOVWF  44
0BA1:  MOVWF  49
0BA2:  BCF    0A.3
0BA3:  CALL   292
0BA4:  BSF    0A.3
0BA5:  MOVF   78,W
0BA6:  MOVWF  3D
....................    min = rm_bcd(read_ds1302(0x83)); 
*
08A2:  MOVLW  83
08A3:  MOVWF  48
08A4:  BCF    0A.3
08A5:  CALL   23E
08A6:  BSF    0A.3
08A7:  MOVF   78,W
08A8:  MOVWF  44
08A9:  MOVWF  49
08AA:  BCF    0A.3
08AB:  CALL   292
08AC:  BSF    0A.3
08AD:  MOVF   78,W
08AE:  MOVWF  3C
*
0BA7:  MOVLW  83
0BA8:  MOVWF  48
0BA9:  BCF    0A.3
0BAA:  CALL   23E
0BAB:  BSF    0A.3
0BAC:  MOVF   78,W
0BAD:  MOVWF  44
0BAE:  MOVWF  49
0BAF:  BCF    0A.3
0BB0:  CALL   292
0BB1:  BSF    0A.3
0BB2:  MOVF   78,W
0BB3:  MOVWF  3C
....................    sec = rm_bcd(read_ds1302(0x81)); 
*
08AF:  MOVLW  81
08B0:  MOVWF  48
08B1:  BCF    0A.3
08B2:  CALL   23E
08B3:  BSF    0A.3
08B4:  MOVF   78,W
08B5:  MOVWF  44
08B6:  MOVWF  49
08B7:  BCF    0A.3
08B8:  CALL   292
08B9:  BSF    0A.3
08BA:  MOVF   78,W
08BB:  MOVWF  3B
*
0BB4:  MOVLW  81
0BB5:  MOVWF  48
0BB6:  BCF    0A.3
0BB7:  CALL   23E
0BB8:  BSF    0A.3
0BB9:  MOVF   78,W
0BBA:  MOVWF  44
0BBB:  MOVWF  49
0BBC:  BCF    0A.3
0BBD:  CALL   292
0BBE:  BSF    0A.3
0BBF:  MOVF   78,W
0BC0:  MOVWF  3B
.................... } 
....................  
.................... void rtc_write_nvr(BYTE address, BYTE data) { 
....................    write_ds1302(address|0xc0,data); 
.................... } 
....................  
.................... BYTE rtc_read_nvr(BYTE address) { 
....................     return(read_ds1302(address|0xc1)); 
.................... } 
....................  
....................  
....................  
....................  
....................  
....................  
.................... #define input1 PIN_C0 
.................... #define input2 PIN_C1 
.................... #define input3 PIN_C4 
.................... #define input4 PIN_C5 
.................... #define enable_a PIN_C6 
.................... #define enable_b PIN_C7 
....................  
.................... #define normal PIN_D0 
.................... #define tehlike PIN_D1 
.................... #define uyari PIN_D2 
.................... #define buzzer PIN_D3 
.................... #define gaz_seviyesi PIN_E2 
....................  
....................  
.................... int temperature; 
.................... int humidity; 
.................... int saniye,dakika,saat,gun,ay,yil,haftanin_gunu;   //DS1302 DEÐÝÞKENLERÝ 
.................... int sayici=0,zamanlayici=0; 
.................... //unsigned int8 kesme=0; 
....................  
....................  
.................... #int_timer0  
.................... void timer0_kesme() //SAYICI 
.................... { 
.................... set_timer0(255); 
*
0040:  MOVLW  FF
0041:  MOVWF  01
.................... sayici++; 
0042:  INCF   42,F
.................... } 
....................  
0043:  BCF    0B.2
0044:  BCF    0A.3
0045:  BCF    0A.4
0046:  GOTO   021
.................... #int_timer1 
.................... void timer1_kesme() //ZAMANLAYICI 
.................... { 
....................  
.................... set_timer1(63036); 
0047:  CLRF   0E
0048:  MOVLW  F6
0049:  MOVWF  0F
004A:  MOVLW  3C
004B:  MOVWF  0E
....................  
.................... if(sayici==1 && zamanlayici<500) 
004C:  DECFSZ 42,W
004D:  GOTO   05D
.................... { 
....................  
.................... output_high(PIN_E0); 
004E:  BSF    03.5
004F:  BCF    09.0
0050:  BCF    03.5
0051:  BSF    09.0
.................... zamanlayici++; 
0052:  INCF   43,F
....................  
.................... if(zamanlayici==500) 
0053:  MOVF   43,W
0054:  SUBLW  F4
0055:  BTFSS  03.2
0056:  GOTO   05D
.................... { 
....................  
.................... output_low(PIN_E0); 
0057:  BSF    03.5
0058:  BCF    09.0
0059:  BCF    03.5
005A:  BCF    09.0
.................... zamanlayici=0; 
005B:  CLRF   43
.................... sayici=0; 
005C:  CLRF   42
....................  
.................... } 
.................... } 
005D:  BCF    0C.0
005E:  BCF    0A.3
005F:  BCF    0A.4
0060:  GOTO   021
.................... } 
....................  
.................... /* 
.................... #int_timer2 
.................... void timer2_kesme(){ 
....................  set_timer2(5); 
....................  kesme++; 
.................... if(input(PIN_E0)){ 
....................  
.................... output_b(kesme); 
.................... lcd_init(); 
.................... printf(lcd_putc,"\f kesme=%u",kesme); 
.................... } 
.................... } 
.................... */ 
....................  
....................  
....................  
.................... void main() 
*
0800:  MOVLW  FF
0801:  MOVWF  38
0802:  CLRF   42
0803:  CLRF   43
0804:  BSF    03.5
0805:  BSF    1F.0
0806:  BSF    1F.1
0807:  BSF    1F.2
0808:  BCF    1F.3
0809:  MOVLW  07
080A:  MOVWF  1C
080B:  BCF    03.7
080C:  MOVLW  1F
080D:  ANDWF  03,F
....................  
.................... { 
....................  
....................    lcd_init(); 
*
0811:  BCF    0A.3
0812:  GOTO   151
0813:  BSF    0A.3
....................     
....................    lcd_gotoxy(1,1);  
0814:  MOVLW  01
0815:  MOVWF  4E
0816:  MOVWF  4F
0817:  BCF    0A.3
0818:  CALL   17D
0819:  BSF    0A.3
....................    lcd_putc("KOU - MIKRO"); 
081A:  MOVLW  61
081B:  BSF    03.6
081C:  MOVWF  0D
081D:  MOVLW  00
081E:  MOVWF  0F
081F:  BCF    0A.3
0820:  BCF    03.6
0821:  CALL   1C6
0822:  BSF    0A.3
....................     
....................    lcd_gotoxy(1,2);  
0823:  MOVLW  01
0824:  MOVWF  4E
0825:  MOVLW  02
0826:  MOVWF  4F
0827:  BCF    0A.3
0828:  CALL   17D
0829:  BSF    0A.3
....................    lcd_putc("   PROJE"); 
082A:  MOVLW  67
082B:  BSF    03.6
082C:  MOVWF  0D
082D:  MOVLW  00
082E:  MOVWF  0F
082F:  BCF    0A.3
0830:  BCF    03.6
0831:  CALL   1C6
0832:  BSF    0A.3
....................    delay_ms(100); 
0833:  MOVLW  64
0834:  MOVWF  4E
0835:  BCF    0A.3
0836:  CALL   0F6
0837:  BSF    0A.3
....................  
....................    lcd_gotoxy(1,1); 
0838:  MOVLW  01
0839:  MOVWF  4E
083A:  MOVWF  4F
083B:  BCF    0A.3
083C:  CALL   17D
083D:  BSF    0A.3
....................    lcd_putc("\fUmutcan GOK"); 
083E:  MOVLW  6C
083F:  BSF    03.6
0840:  MOVWF  0D
0841:  MOVLW  00
0842:  MOVWF  0F
0843:  BCF    0A.3
0844:  BCF    03.6
0845:  CALL   1C6
0846:  BSF    0A.3
....................     
....................    lcd_gotoxy(1,2);  
0847:  MOVLW  01
0848:  MOVWF  4E
0849:  MOVLW  02
084A:  MOVWF  4F
084B:  BCF    0A.3
084C:  CALL   17D
084D:  BSF    0A.3
....................    lcd_putc("180223047"); 
084E:  MOVLW  73
084F:  BSF    03.6
0850:  MOVWF  0D
0851:  MOVLW  00
0852:  MOVWF  0F
0853:  BCF    0A.3
0854:  BCF    03.6
0855:  CALL   1C6
0856:  BSF    0A.3
....................    delay_ms(100); 
0857:  MOVLW  64
0858:  MOVWF  4E
0859:  BCF    0A.3
085A:  CALL   0F6
085B:  BSF    0A.3
....................  
....................        kesme: 
....................        setup_psp(PSP_DISABLED);        // PSP birimi devre dýþý 
085C:  BSF    03.5
085D:  BCF    09.4
....................      //setup_timer_1(T1_DISABLED);     // T1 zamanlayýcýsý devre dýþý 
....................        setup_timer_2(T2_DISABLED,0,1); // T2 zamanlayýcýsý devre dýþý 
085E:  MOVLW  00
085F:  MOVWF  78
0860:  BCF    03.5
0861:  MOVWF  12
0862:  MOVLW  00
0863:  BSF    03.5
0864:  MOVWF  12
....................        setup_adc_ports(NO_ANALOGS);    // ANALOG giriþ yok 
0865:  BSF    1F.0
0866:  BSF    1F.1
0867:  BSF    1F.2
0868:  BCF    1F.3
....................        setup_adc(ADC_OFF);             // ADC birimi devre dýþý 
0869:  BCF    03.5
086A:  BCF    1F.0
....................      
....................        setup_timer_1(T1_INTERNAL | T1_DIV_BY_8); 
086B:  MOVLW  B5
086C:  MOVWF  10
....................        set_timer1(63036); 
086D:  CLRF   0E
086E:  MOVLW  F6
086F:  MOVWF  0F
0870:  MOVLW  3C
0871:  MOVWF  0E
....................    
....................        setup_timer_0(RTCC_EXT_H_TO_L | RTCC_DIV_1); 
0872:  BSF    03.5
0873:  MOVF   01,W
0874:  ANDLW  C7
0875:  IORLW  38
0876:  MOVWF  01
....................        set_timer0(255);   
0877:  MOVLW  FF
0878:  BCF    03.5
0879:  MOVWF  01
....................         
....................        enable_interrupts(INT_timer0); 
087A:  BSF    0B.5
....................        enable_interrupts(INT_timer1); 
087B:  BSF    03.5
087C:  BSF    0C.0
....................        enable_interrupts(GLOBAL); 
087D:  MOVLW  C0
087E:  BCF    03.5
087F:  IORWF  0B,F
....................        while(1) 
....................        break; 
0880:  GOTO   082
0881:  GOTO   080
....................         
....................        output_high(enable_a); 
0882:  BCF    38.6
0883:  MOVF   38,W
0884:  BSF    03.5
0885:  MOVWF  07
0886:  BCF    03.5
0887:  BSF    07.6
....................        output_high(enable_b); 
0888:  BCF    38.7
0889:  MOVF   38,W
088A:  BSF    03.5
088B:  MOVWF  07
088C:  BCF    03.5
088D:  BSF    07.7
....................    
....................    set_tris_a(0x18);   // RA0, RA1, RA2, RA3 pinleri giriþ 
088E:  MOVLW  18
088F:  BSF    03.5
0890:  MOVWF  05
....................    
....................    rtc_init(); 
0891:  BCF    0A.3
0892:  BCF    03.5
0893:  GOTO   26E
0894:  BSF    0A.3
....................    
....................  
....................     
....................  
....................         
....................        
....................         
....................    while(TRUE) 
....................    {    
....................  
....................        rtc_get_time(saat,dakika,saniye);  //DS1302'den saat,dakika,saniye bilgileri alýnýyor 
....................        rtc_get_date(gun,ay,yil,haftanin_gunu);//DS1302'den gün,ay,yýl ve günün isim bilgisi alýnýyor 
....................         
....................        read_dht(); 
*
08F0:  BCF    0A.3
08F1:  CALL   2D1
08F2:  BSF    0A.3
....................        temperature=dht_dat[2]; 
08F3:  MOVF   30,W
08F4:  MOVWF  39
....................        humidity=dht_dat[0]; 
08F5:  MOVF   2E,W
08F6:  MOVWF  3A
....................   
....................       switch(haftanin_gunu)   //DS1302'den sayýsal olarak alýnan haftanýn günü bilgisine 
08F7:  MOVLW  01
08F8:  SUBWF  41,W
08F9:  ADDLW  F9
08FA:  BTFSC  03.0
08FB:  GOTO   19E
08FC:  ADDLW  07
08FD:  GOTO   7AB
....................      {               //metin olarak karþýlýk atanýyor. 
....................       
....................      case 1:  lcd_gotoxy(3,2);printf(lcd_putc,"PAZ");break;  // Eðer "1" ise LCD'ye PAZ yaz 
08FE:  MOVLW  03
08FF:  MOVWF  4E
0900:  MOVLW  02
0901:  MOVWF  4F
0902:  BCF    0A.3
0903:  CALL   17D
0904:  BSF    0A.3
0905:  MOVLW  50
0906:  MOVWF  4D
0907:  BCF    0A.3
0908:  CALL   19F
0909:  BSF    0A.3
090A:  MOVLW  41
090B:  MOVWF  4D
090C:  BCF    0A.3
090D:  CALL   19F
090E:  BSF    0A.3
090F:  MOVLW  5A
0910:  MOVWF  4D
0911:  BCF    0A.3
0912:  CALL   19F
0913:  BSF    0A.3
0914:  GOTO   19E
....................      case 2:  lcd_gotoxy(3,2);printf(lcd_putc,"PZT");break;  // Eðer "2" ise LCD'ye PZT yaz 
0915:  MOVLW  03
0916:  MOVWF  4E
0917:  MOVLW  02
0918:  MOVWF  4F
0919:  BCF    0A.3
091A:  CALL   17D
091B:  BSF    0A.3
091C:  MOVLW  50
091D:  MOVWF  4D
091E:  BCF    0A.3
091F:  CALL   19F
0920:  BSF    0A.3
0921:  MOVLW  5A
0922:  MOVWF  4D
0923:  BCF    0A.3
0924:  CALL   19F
0925:  BSF    0A.3
0926:  MOVLW  54
0927:  MOVWF  4D
0928:  BCF    0A.3
0929:  CALL   19F
092A:  BSF    0A.3
092B:  GOTO   19E
....................      case 3:  lcd_gotoxy(3,2);printf(lcd_putc,"SAL");break;  // Eðer "3" ise LCD'ye SAL yaz 
092C:  MOVLW  03
092D:  MOVWF  4E
092E:  MOVLW  02
092F:  MOVWF  4F
0930:  BCF    0A.3
0931:  CALL   17D
0932:  BSF    0A.3
0933:  MOVLW  53
0934:  MOVWF  4D
0935:  BCF    0A.3
0936:  CALL   19F
0937:  BSF    0A.3
0938:  MOVLW  41
0939:  MOVWF  4D
093A:  BCF    0A.3
093B:  CALL   19F
093C:  BSF    0A.3
093D:  MOVLW  4C
093E:  MOVWF  4D
093F:  BCF    0A.3
0940:  CALL   19F
0941:  BSF    0A.3
0942:  GOTO   19E
....................      case 4:  lcd_gotoxy(3,2);printf(lcd_putc,"CRS");break;  // Eðer "4" ise LCD'ye CRS yaz 
0943:  MOVLW  03
0944:  MOVWF  4E
0945:  MOVLW  02
0946:  MOVWF  4F
0947:  BCF    0A.3
0948:  CALL   17D
0949:  BSF    0A.3
094A:  MOVLW  43
094B:  MOVWF  4D
094C:  BCF    0A.3
094D:  CALL   19F
094E:  BSF    0A.3
094F:  MOVLW  52
0950:  MOVWF  4D
0951:  BCF    0A.3
0952:  CALL   19F
0953:  BSF    0A.3
0954:  MOVLW  53
0955:  MOVWF  4D
0956:  BCF    0A.3
0957:  CALL   19F
0958:  BSF    0A.3
0959:  GOTO   19E
....................      case 5:  lcd_gotoxy(3,2);printf(lcd_putc,"PER");break;  // Eðer "5" ise LCD'ye PER yaz 
095A:  MOVLW  03
095B:  MOVWF  4E
095C:  MOVLW  02
095D:  MOVWF  4F
095E:  BCF    0A.3
095F:  CALL   17D
0960:  BSF    0A.3
0961:  MOVLW  50
0962:  MOVWF  4D
0963:  BCF    0A.3
0964:  CALL   19F
0965:  BSF    0A.3
0966:  MOVLW  45
0967:  MOVWF  4D
0968:  BCF    0A.3
0969:  CALL   19F
096A:  BSF    0A.3
096B:  MOVLW  52
096C:  MOVWF  4D
096D:  BCF    0A.3
096E:  CALL   19F
096F:  BSF    0A.3
0970:  GOTO   19E
....................      case 6:  lcd_gotoxy(3,2);printf(lcd_putc,"CUM");break;  // Eðer "6" ise LCD'ye CUM yaz 
0971:  MOVLW  03
0972:  MOVWF  4E
0973:  MOVLW  02
0974:  MOVWF  4F
0975:  BCF    0A.3
0976:  CALL   17D
0977:  BSF    0A.3
0978:  MOVLW  43
0979:  MOVWF  4D
097A:  BCF    0A.3
097B:  CALL   19F
097C:  BSF    0A.3
097D:  MOVLW  55
097E:  MOVWF  4D
097F:  BCF    0A.3
0980:  CALL   19F
0981:  BSF    0A.3
0982:  MOVLW  4D
0983:  MOVWF  4D
0984:  BCF    0A.3
0985:  CALL   19F
0986:  BSF    0A.3
0987:  GOTO   19E
....................      case 7:  lcd_gotoxy(3,2);printf(lcd_putc,"CTS");break;  // Eðer "7" ise LCD'ye CTS yaz 
0988:  MOVLW  03
0989:  MOVWF  4E
098A:  MOVLW  02
098B:  MOVWF  4F
098C:  BCF    0A.3
098D:  CALL   17D
098E:  BSF    0A.3
098F:  MOVLW  43
0990:  MOVWF  4D
0991:  BCF    0A.3
0992:  CALL   19F
0993:  BSF    0A.3
0994:  MOVLW  54
0995:  MOVWF  4D
0996:  BCF    0A.3
0997:  CALL   19F
0998:  BSF    0A.3
0999:  MOVLW  53
099A:  MOVWF  4D
099B:  BCF    0A.3
099C:  CALL   19F
099D:  BSF    0A.3
....................       
....................       
....................      } 
....................       
....................       if(input(PIN_A2))   
099E:  BTFSS  05.2
099F:  GOTO   287
....................       { 
....................          printf(lcd_putc,"\f"); 
09A0:  MOVLW  0C
09A1:  MOVWF  4D
09A2:  BCF    0A.3
09A3:  CALL   19F
09A4:  BSF    0A.3
....................          restart_wdt(); 
09A5:  CLRWDT
....................          write_eeprom(0,temperature);  // 0 (0x00) adresine saniye deðerini yaz 
09A6:  MOVF   0B,W
09A7:  MOVWF  77
09A8:  BCF    0B.7
09A9:  BSF    03.6
09AA:  CLRF   0D
09AB:  BCF    03.6
09AC:  MOVF   39,W
09AD:  BSF    03.6
09AE:  MOVWF  0C
09AF:  BSF    03.5
09B0:  BCF    0C.7
09B1:  BSF    0C.2
09B2:  MOVLW  55
09B3:  MOVWF  0D
09B4:  MOVLW  AA
09B5:  MOVWF  0D
09B6:  BSF    0C.1
09B7:  BTFSC  0C.1
09B8:  GOTO   1B7
09B9:  BCF    0C.2
09BA:  MOVF   77,W
09BB:  BCF    03.5
09BC:  BCF    03.6
09BD:  IORWF  0B,F
....................          write_eeprom(1,humidity);   // 1 (0x01) adresine milisaniye deðerini yazr 
09BE:  MOVF   0B,W
09BF:  MOVWF  77
09C0:  BCF    0B.7
09C1:  MOVLW  01
09C2:  BSF    03.6
09C3:  MOVWF  0D
09C4:  BCF    03.6
09C5:  MOVF   3A,W
09C6:  BSF    03.6
09C7:  MOVWF  0C
09C8:  BSF    03.5
09C9:  BCF    0C.7
09CA:  BSF    0C.2
09CB:  MOVLW  55
09CC:  MOVWF  0D
09CD:  MOVLW  AA
09CE:  MOVWF  0D
09CF:  BSF    0C.1
09D0:  BTFSC  0C.1
09D1:  GOTO   1D0
09D2:  BCF    0C.2
09D3:  MOVF   77,W
09D4:  BCF    03.5
09D5:  BCF    03.6
09D6:  IORWF  0B,F
....................          write_eeprom(2,saniye); 
09D7:  MOVF   0B,W
09D8:  MOVWF  77
09D9:  BCF    0B.7
09DA:  MOVLW  02
09DB:  BSF    03.6
09DC:  MOVWF  0D
09DD:  BCF    03.6
09DE:  MOVF   3B,W
09DF:  BSF    03.6
09E0:  MOVWF  0C
09E1:  BSF    03.5
09E2:  BCF    0C.7
09E3:  BSF    0C.2
09E4:  MOVLW  55
09E5:  MOVWF  0D
09E6:  MOVLW  AA
09E7:  MOVWF  0D
09E8:  BSF    0C.1
09E9:  BTFSC  0C.1
09EA:  GOTO   1E9
09EB:  BCF    0C.2
09EC:  MOVF   77,W
09ED:  BCF    03.5
09EE:  BCF    03.6
09EF:  IORWF  0B,F
....................          write_eeprom(3,dakika); 
09F0:  MOVF   0B,W
09F1:  MOVWF  77
09F2:  BCF    0B.7
09F3:  MOVLW  03
09F4:  BSF    03.6
09F5:  MOVWF  0D
09F6:  BCF    03.6
09F7:  MOVF   3C,W
09F8:  BSF    03.6
09F9:  MOVWF  0C
09FA:  BSF    03.5
09FB:  BCF    0C.7
09FC:  BSF    0C.2
09FD:  MOVLW  55
09FE:  MOVWF  0D
09FF:  MOVLW  AA
0A00:  MOVWF  0D
0A01:  BSF    0C.1
0A02:  BTFSC  0C.1
0A03:  GOTO   202
0A04:  BCF    0C.2
0A05:  MOVF   77,W
0A06:  BCF    03.5
0A07:  BCF    03.6
0A08:  IORWF  0B,F
....................          write_eeprom(4,saat); 
0A09:  MOVF   0B,W
0A0A:  MOVWF  77
0A0B:  BCF    0B.7
0A0C:  MOVLW  04
0A0D:  BSF    03.6
0A0E:  MOVWF  0D
0A0F:  BCF    03.6
0A10:  MOVF   3D,W
0A11:  BSF    03.6
0A12:  MOVWF  0C
0A13:  BSF    03.5
0A14:  BCF    0C.7
0A15:  BSF    0C.2
0A16:  MOVLW  55
0A17:  MOVWF  0D
0A18:  MOVLW  AA
0A19:  MOVWF  0D
0A1A:  BSF    0C.1
0A1B:  BTFSC  0C.1
0A1C:  GOTO   21B
0A1D:  BCF    0C.2
0A1E:  MOVF   77,W
0A1F:  BCF    03.5
0A20:  BCF    03.6
0A21:  IORWF  0B,F
....................          write_eeprom(5,gun); 
0A22:  MOVF   0B,W
0A23:  MOVWF  77
0A24:  BCF    0B.7
0A25:  MOVLW  05
0A26:  BSF    03.6
0A27:  MOVWF  0D
0A28:  BCF    03.6
0A29:  MOVF   3E,W
0A2A:  BSF    03.6
0A2B:  MOVWF  0C
0A2C:  BSF    03.5
0A2D:  BCF    0C.7
0A2E:  BSF    0C.2
0A2F:  MOVLW  55
0A30:  MOVWF  0D
0A31:  MOVLW  AA
0A32:  MOVWF  0D
0A33:  BSF    0C.1
0A34:  BTFSC  0C.1
0A35:  GOTO   234
0A36:  BCF    0C.2
0A37:  MOVF   77,W
0A38:  BCF    03.5
0A39:  BCF    03.6
0A3A:  IORWF  0B,F
....................          write_eeprom(6,ay); 
0A3B:  MOVF   0B,W
0A3C:  MOVWF  77
0A3D:  BCF    0B.7
0A3E:  MOVLW  06
0A3F:  BSF    03.6
0A40:  MOVWF  0D
0A41:  BCF    03.6
0A42:  MOVF   3F,W
0A43:  BSF    03.6
0A44:  MOVWF  0C
0A45:  BSF    03.5
0A46:  BCF    0C.7
0A47:  BSF    0C.2
0A48:  MOVLW  55
0A49:  MOVWF  0D
0A4A:  MOVLW  AA
0A4B:  MOVWF  0D
0A4C:  BSF    0C.1
0A4D:  BTFSC  0C.1
0A4E:  GOTO   24D
0A4F:  BCF    0C.2
0A50:  MOVF   77,W
0A51:  BCF    03.5
0A52:  BCF    03.6
0A53:  IORWF  0B,F
....................          write_eeprom(7,yil); 
0A54:  MOVF   0B,W
0A55:  MOVWF  77
0A56:  BCF    0B.7
0A57:  MOVLW  07
0A58:  BSF    03.6
0A59:  MOVWF  0D
0A5A:  BCF    03.6
0A5B:  MOVF   40,W
0A5C:  BSF    03.6
0A5D:  MOVWF  0C
0A5E:  BSF    03.5
0A5F:  BCF    0C.7
0A60:  BSF    0C.2
0A61:  MOVLW  55
0A62:  MOVWF  0D
0A63:  MOVLW  AA
0A64:  MOVWF  0D
0A65:  BSF    0C.1
0A66:  BTFSC  0C.1
0A67:  GOTO   266
0A68:  BCF    0C.2
0A69:  MOVF   77,W
0A6A:  BCF    03.5
0A6B:  BCF    03.6
0A6C:  IORWF  0B,F
....................          write_eeprom(8,gaz_seviyesi); 
0A6D:  MOVF   0B,W
0A6E:  MOVWF  77
0A6F:  BCF    0B.7
0A70:  MOVLW  08
0A71:  BSF    03.6
0A72:  MOVWF  0D
0A73:  MOVLW  4A
0A74:  MOVWF  0C
0A75:  BSF    03.5
0A76:  BCF    0C.7
0A77:  BSF    0C.2
0A78:  MOVLW  55
0A79:  MOVWF  0D
0A7A:  MOVLW  AA
0A7B:  MOVWF  0D
0A7C:  BSF    0C.1
0A7D:  BTFSC  0C.1
0A7E:  GOTO   27D
0A7F:  BCF    0C.2
0A80:  MOVF   77,W
0A81:  BCF    03.5
0A82:  BCF    03.6
0A83:  IORWF  0B,F
....................  
....................           
....................          while(input(PIN_A2)); 
0A84:  BTFSC  05.2
0A85:  GOTO   284
....................          restart_wdt(); 
0A86:  CLRWDT
....................           
....................       } 
....................  
....................       if(input(PIN_A3))   
0A87:  BTFSS  05.3
0A88:  GOTO   38A
....................       {    
....................        
....................           printf(lcd_putc,"\f"); 
0A89:  MOVLW  0C
0A8A:  MOVWF  4D
0A8B:  BCF    0A.3
0A8C:  CALL   19F
0A8D:  BSF    0A.3
....................           restart_wdt(); 
0A8E:  CLRWDT
....................       
....................          while(input(PIN_A3)) 
0A8F:  BTFSS  05.3
0A90:  GOTO   38A
....................          { 
....................  
....................             lcd_gotoxy(1,1); 
0A91:  MOVLW  01
0A92:  MOVWF  4E
0A93:  MOVWF  4F
0A94:  BCF    0A.3
0A95:  CALL   17D
0A96:  BSF    0A.3
....................             printf(lcd_putc,"\fSicaklik:%dC,Nem:%d",read_eeprom(0),read_eeprom(1)); 
0A97:  BSF    03.6
0A98:  CLRF   0D
0A99:  BSF    03.5
0A9A:  BCF    0C.7
0A9B:  BSF    0C.0
0A9C:  BCF    03.5
0A9D:  MOVF   0C,W
0A9E:  BCF    03.6
0A9F:  MOVWF  44
0AA0:  MOVLW  01
0AA1:  BSF    03.6
0AA2:  MOVWF  0D
0AA3:  BSF    03.5
0AA4:  BCF    0C.7
0AA5:  BSF    0C.0
0AA6:  BCF    03.5
0AA7:  MOVF   0C,W
0AA8:  BCF    03.6
0AA9:  MOVWF  45
0AAA:  MOVLW  78
0AAB:  BSF    03.6
0AAC:  MOVWF  0D
0AAD:  MOVLW  00
0AAE:  MOVWF  0F
0AAF:  BCF    03.0
0AB0:  MOVLW  0A
0AB1:  BCF    03.6
0AB2:  MOVWF  46
0AB3:  BCF    0A.3
0AB4:  CALL   33A
0AB5:  BSF    0A.3
0AB6:  MOVF   44,W
0AB7:  MOVWF  47
0AB8:  MOVLW  18
0AB9:  MOVWF  48
0ABA:  BCF    0A.3
0ABB:  CALL   3A3
0ABC:  BSF    0A.3
0ABD:  MOVLW  7E
0ABE:  BSF    03.6
0ABF:  MOVWF  0D
0AC0:  MOVLW  00
0AC1:  MOVWF  0F
0AC2:  BCF    03.0
0AC3:  MOVLW  06
0AC4:  BCF    03.6
0AC5:  MOVWF  46
0AC6:  BCF    0A.3
0AC7:  CALL   33A
0AC8:  BSF    0A.3
0AC9:  MOVF   45,W
0ACA:  MOVWF  47
0ACB:  MOVLW  18
0ACC:  MOVWF  48
0ACD:  BCF    0A.3
0ACE:  CALL   3A3
0ACF:  BSF    0A.3
....................             lcd_gotoxy(1,2); 
0AD0:  MOVLW  01
0AD1:  MOVWF  4E
0AD2:  MOVLW  02
0AD3:  MOVWF  4F
0AD4:  BCF    0A.3
0AD5:  CALL   17D
0AD6:  BSF    0A.3
....................             printf(lcd_putc,"Gaz(1/0):%d",read_eeprom(8)); 
0AD7:  MOVLW  08
0AD8:  BSF    03.6
0AD9:  MOVWF  0D
0ADA:  BSF    03.5
0ADB:  BCF    0C.7
0ADC:  BSF    0C.0
0ADD:  BCF    03.5
0ADE:  MOVF   0C,W
0ADF:  BCF    03.6
0AE0:  MOVWF  44
0AE1:  MOVLW  83
0AE2:  BSF    03.6
0AE3:  MOVWF  0D
0AE4:  MOVLW  00
0AE5:  MOVWF  0F
0AE6:  BCF    03.0
0AE7:  MOVLW  09
0AE8:  BCF    03.6
0AE9:  MOVWF  46
0AEA:  BCF    0A.3
0AEB:  CALL   33A
0AEC:  BSF    0A.3
0AED:  MOVF   44,W
0AEE:  MOVWF  47
0AEF:  MOVLW  18
0AF0:  MOVWF  48
0AF1:  BCF    0A.3
0AF2:  CALL   3A3
0AF3:  BSF    0A.3
....................             lcd_gotoxy(1,3); 
0AF4:  MOVLW  01
0AF5:  MOVWF  4E
0AF6:  MOVLW  03
0AF7:  MOVWF  4F
0AF8:  BCF    0A.3
0AF9:  CALL   17D
0AFA:  BSF    0A.3
....................             printf(lcd_putc," %d:%d:%d",read_eeprom(4),read_eeprom(3), read_eeprom(2)); 
0AFB:  MOVLW  04
0AFC:  BSF    03.6
0AFD:  MOVWF  0D
0AFE:  BSF    03.5
0AFF:  BCF    0C.7
0B00:  BSF    0C.0
0B01:  BCF    03.5
0B02:  MOVF   0C,W
0B03:  BCF    03.6
0B04:  MOVWF  44
0B05:  MOVLW  03
0B06:  BSF    03.6
0B07:  MOVWF  0D
0B08:  BSF    03.5
0B09:  BCF    0C.7
0B0A:  BSF    0C.0
0B0B:  BCF    03.5
0B0C:  MOVF   0C,W
0B0D:  BCF    03.6
0B0E:  MOVWF  45
0B0F:  MOVLW  02
0B10:  BSF    03.6
0B11:  MOVWF  0D
0B12:  BSF    03.5
0B13:  BCF    0C.7
0B14:  BSF    0C.0
0B15:  BCF    03.5
0B16:  MOVF   0C,W
0B17:  BCF    03.6
0B18:  MOVWF  46
0B19:  MOVLW  20
0B1A:  MOVWF  4D
0B1B:  BCF    0A.3
0B1C:  CALL   19F
0B1D:  BSF    0A.3
0B1E:  MOVF   44,W
0B1F:  MOVWF  47
0B20:  MOVLW  18
0B21:  MOVWF  48
0B22:  BCF    0A.3
0B23:  CALL   3A3
0B24:  BSF    0A.3
0B25:  MOVLW  3A
0B26:  MOVWF  4D
0B27:  BCF    0A.3
0B28:  CALL   19F
0B29:  BSF    0A.3
0B2A:  MOVF   45,W
0B2B:  MOVWF  47
0B2C:  MOVLW  18
0B2D:  MOVWF  48
0B2E:  BCF    0A.3
0B2F:  CALL   3A3
0B30:  BSF    0A.3
0B31:  MOVLW  3A
0B32:  MOVWF  4D
0B33:  BCF    0A.3
0B34:  CALL   19F
0B35:  BSF    0A.3
0B36:  MOVF   46,W
0B37:  MOVWF  47
0B38:  MOVLW  18
0B39:  MOVWF  48
0B3A:  BCF    0A.3
0B3B:  CALL   3A3
0B3C:  BSF    0A.3
....................             lcd_gotoxy(1,4); 
0B3D:  MOVLW  01
0B3E:  MOVWF  4E
0B3F:  MOVLW  04
0B40:  MOVWF  4F
0B41:  BCF    0A.3
0B42:  CALL   17D
0B43:  BSF    0A.3
....................             printf(lcd_putc," %d.%d.%d",read_eeprom(5),read_eeprom(6), read_eeprom(7)); 
0B44:  MOVLW  05
0B45:  BSF    03.6
0B46:  MOVWF  0D
0B47:  BSF    03.5
0B48:  BCF    0C.7
0B49:  BSF    0C.0
0B4A:  BCF    03.5
0B4B:  MOVF   0C,W
0B4C:  BCF    03.6
0B4D:  MOVWF  44
0B4E:  MOVLW  06
0B4F:  BSF    03.6
0B50:  MOVWF  0D
0B51:  BSF    03.5
0B52:  BCF    0C.7
0B53:  BSF    0C.0
0B54:  BCF    03.5
0B55:  MOVF   0C,W
0B56:  BCF    03.6
0B57:  MOVWF  45
0B58:  MOVLW  07
0B59:  BSF    03.6
0B5A:  MOVWF  0D
0B5B:  BSF    03.5
0B5C:  BCF    0C.7
0B5D:  BSF    0C.0
0B5E:  BCF    03.5
0B5F:  MOVF   0C,W
0B60:  BCF    03.6
0B61:  MOVWF  46
0B62:  MOVLW  20
0B63:  MOVWF  4D
0B64:  BCF    0A.3
0B65:  CALL   19F
0B66:  BSF    0A.3
0B67:  MOVF   44,W
0B68:  MOVWF  47
0B69:  MOVLW  18
0B6A:  MOVWF  48
0B6B:  BCF    0A.3
0B6C:  CALL   3A3
0B6D:  BSF    0A.3
0B6E:  MOVLW  2E
0B6F:  MOVWF  4D
0B70:  BCF    0A.3
0B71:  CALL   19F
0B72:  BSF    0A.3
0B73:  MOVF   45,W
0B74:  MOVWF  47
0B75:  MOVLW  18
0B76:  MOVWF  48
0B77:  BCF    0A.3
0B78:  CALL   3A3
0B79:  BSF    0A.3
0B7A:  MOVLW  2E
0B7B:  MOVWF  4D
0B7C:  BCF    0A.3
0B7D:  CALL   19F
0B7E:  BSF    0A.3
0B7F:  MOVF   46,W
0B80:  MOVWF  47
0B81:  MOVLW  18
0B82:  MOVWF  48
0B83:  BCF    0A.3
0B84:  CALL   3A3
0B85:  BSF    0A.3
....................             while(input(PIN_A3)); 
0B86:  BTFSC  05.3
0B87:  GOTO   386
....................             restart_wdt(); 
0B88:  CLRWDT
0B89:  GOTO   28F
....................              
....................          } 
....................       } 
....................        
....................       if(input(PIN_E1))   
0B8A:  BSF    03.5
0B8B:  BSF    09.1
0B8C:  BCF    03.5
0B8D:  BTFSS  09.1
0B8E:  GOTO   48F
....................       { 
....................          printf(lcd_putc,"\f"); 
0B8F:  MOVLW  0C
0B90:  MOVWF  4D
0B91:  BCF    0A.3
0B92:  CALL   19F
0B93:  BSF    0A.3
....................          restart_wdt(); 
0B94:  CLRWDT
....................  
....................          while(input(PIN_E1)) 
0B95:  BSF    03.5
0B96:  BSF    09.1
0B97:  BCF    03.5
0B98:  BTFSS  09.1
0B99:  GOTO   48E
....................          { 
....................             rtc_get_time(saat,dakika,saniye);  //DS1302'den saat,dakika,saniye bilgileri alýnýyor 
....................             rtc_get_date(gun,ay,yil,haftanin_gunu);//DS1302'den gün,ay,yýl ve günün isim bilgisi alýnýyor 
....................            
....................             read_dht(); 
*
0BF5:  BCF    0A.3
0BF6:  CALL   2D1
0BF7:  BSF    0A.3
....................             temperature=dht_dat[2]; 
0BF8:  MOVF   30,W
0BF9:  MOVWF  39
....................             humidity=dht_dat[0]; 
0BFA:  MOVF   2E,W
0BFB:  MOVWF  3A
....................             lcd_gotoxy(1,1); 
0BFC:  MOVLW  01
0BFD:  MOVWF  4E
0BFE:  MOVWF  4F
0BFF:  BCF    0A.3
0C00:  CALL   17D
0C01:  BSF    0A.3
....................             printf(lcd_putc,"\fSicaklik:%dC, Nem:%d\n",temperature,humidity); 
0C02:  MOVLW  89
0C03:  BSF    03.6
0C04:  MOVWF  0D
0C05:  MOVLW  00
0C06:  MOVWF  0F
0C07:  BCF    03.0
0C08:  MOVLW  0A
0C09:  BCF    03.6
0C0A:  MOVWF  46
0C0B:  BCF    0A.3
0C0C:  CALL   33A
0C0D:  BSF    0A.3
0C0E:  MOVF   39,W
0C0F:  MOVWF  47
0C10:  MOVLW  18
0C11:  MOVWF  48
0C12:  BCF    0A.3
0C13:  CALL   3A3
0C14:  BSF    0A.3
0C15:  MOVLW  8F
0C16:  BSF    03.6
0C17:  MOVWF  0D
0C18:  MOVLW  00
0C19:  MOVWF  0F
0C1A:  BCF    03.0
0C1B:  MOVLW  07
0C1C:  BCF    03.6
0C1D:  MOVWF  46
0C1E:  BCF    0A.3
0C1F:  CALL   33A
0C20:  BSF    0A.3
0C21:  MOVF   3A,W
0C22:  MOVWF  47
0C23:  MOVLW  18
0C24:  MOVWF  48
0C25:  BCF    0A.3
0C26:  CALL   3A3
0C27:  BSF    0A.3
0C28:  MOVLW  0A
0C29:  MOVWF  4D
0C2A:  BCF    0A.3
0C2B:  CALL   19F
0C2C:  BSF    0A.3
....................             printf(lcd_putc,"     %02d/%02d/%02d\n",gun,ay,yil); //LCD'ye sýcaklýk,gün,ay,yýl bilgileri yazdýrýlýyor 
0C2D:  MOVLW  95
0C2E:  BSF    03.6
0C2F:  MOVWF  0D
0C30:  MOVLW  00
0C31:  MOVWF  0F
0C32:  BCF    03.0
0C33:  MOVLW  05
0C34:  BCF    03.6
0C35:  MOVWF  46
0C36:  BCF    0A.3
0C37:  CALL   33A
0C38:  BSF    0A.3
0C39:  MOVF   3E,W
0C3A:  MOVWF  44
0C3B:  MOVLW  01
0C3C:  MOVWF  45
0C3D:  BCF    0A.3
0C3E:  CALL   3FA
0C3F:  BSF    0A.3
0C40:  MOVLW  2F
0C41:  MOVWF  4D
0C42:  BCF    0A.3
0C43:  CALL   19F
0C44:  BSF    0A.3
0C45:  MOVF   3F,W
0C46:  MOVWF  44
0C47:  MOVLW  01
0C48:  MOVWF  45
0C49:  BCF    0A.3
0C4A:  CALL   3FA
0C4B:  BSF    0A.3
0C4C:  MOVLW  2F
0C4D:  MOVWF  4D
0C4E:  BCF    0A.3
0C4F:  CALL   19F
0C50:  BSF    0A.3
0C51:  MOVF   40,W
0C52:  MOVWF  44
0C53:  MOVLW  01
0C54:  MOVWF  45
0C55:  BCF    0A.3
0C56:  CALL   3FA
0C57:  BSF    0A.3
0C58:  MOVLW  0A
0C59:  MOVWF  4D
0C5A:  BCF    0A.3
0C5B:  CALL   19F
0C5C:  BSF    0A.3
....................             printf(lcd_putc,"     %02d:%02d:%02d",saat,dakika,saniye);   //LCD'ye saat,dakika ve saniye deðerlerini yaz 
0C5D:  MOVLW  A0
0C5E:  BSF    03.6
0C5F:  MOVWF  0D
0C60:  MOVLW  00
0C61:  MOVWF  0F
0C62:  BCF    03.0
0C63:  MOVLW  05
0C64:  BCF    03.6
0C65:  MOVWF  46
0C66:  BCF    0A.3
0C67:  CALL   33A
0C68:  BSF    0A.3
0C69:  MOVF   3D,W
0C6A:  MOVWF  44
0C6B:  MOVLW  01
0C6C:  MOVWF  45
0C6D:  BCF    0A.3
0C6E:  CALL   3FA
0C6F:  BSF    0A.3
0C70:  MOVLW  3A
0C71:  MOVWF  4D
0C72:  BCF    0A.3
0C73:  CALL   19F
0C74:  BSF    0A.3
0C75:  MOVF   3C,W
0C76:  MOVWF  44
0C77:  MOVLW  01
0C78:  MOVWF  45
0C79:  BCF    0A.3
0C7A:  CALL   3FA
0C7B:  BSF    0A.3
0C7C:  MOVLW  3A
0C7D:  MOVWF  4D
0C7E:  BCF    0A.3
0C7F:  CALL   19F
0C80:  BSF    0A.3
0C81:  MOVF   3B,W
0C82:  MOVWF  44
0C83:  MOVLW  01
0C84:  MOVWF  45
0C85:  BCF    0A.3
0C86:  CALL   3FA
0C87:  BSF    0A.3
....................             delay_ms(250); 
0C88:  MOVLW  FA
0C89:  MOVWF  4E
0C8A:  BCF    0A.3
0C8B:  CALL   0F6
0C8C:  BSF    0A.3
0C8D:  GOTO   395
....................          } 
....................          restart_wdt(); 
0C8E:  CLRWDT
....................           
....................       } 
....................        
....................             if(input(PIN_E2)) 
0C8F:  BSF    03.5
0C90:  BSF    09.2
0C91:  BCF    03.5
0C92:  BTFSS  09.2
0C93:  GOTO   5B3
....................       { 
....................           printf(lcd_putc,"\f"); 
0C94:  MOVLW  0C
0C95:  MOVWF  4D
0C96:  BCF    0A.3
0C97:  CALL   19F
0C98:  BSF    0A.3
....................           restart_wdt(); 
0C99:  CLRWDT
....................            
....................          while(input(PIN_E2)){ 
0C9A:  BSF    03.5
0C9B:  BSF    09.2
0C9C:  BCF    03.5
0C9D:  BTFSS  09.2
0C9E:  GOTO   5AD
....................          printf(lcd_putc,"\f"); 
0C9F:  MOVLW  0C
0CA0:  MOVWF  4D
0CA1:  BCF    0A.3
0CA2:  CALL   19F
0CA3:  BSF    0A.3
....................          lcd_gotoxy(1,1); 
0CA4:  MOVLW  01
0CA5:  MOVWF  4E
0CA6:  MOVWF  4F
0CA7:  BCF    0A.3
0CA8:  CALL   17D
0CA9:  BSF    0A.3
....................          printf(lcd_putc,"\fYuksek Gaz Seviyesi\n"); 
0CAA:  MOVLW  AA
0CAB:  BSF    03.6
0CAC:  MOVWF  0D
0CAD:  MOVLW  00
0CAE:  MOVWF  0F
0CAF:  BCF    0A.3
0CB0:  BCF    03.6
0CB1:  CALL   1C6
0CB2:  BSF    0A.3
....................          printf(lcd_putc,"!  !  !  !  !  !  !"); 
0CB3:  MOVLW  B5
0CB4:  BSF    03.6
0CB5:  MOVWF  0D
0CB6:  MOVLW  00
0CB7:  MOVWF  0F
0CB8:  BCF    0A.3
0CB9:  BCF    03.6
0CBA:  CALL   1C6
0CBB:  BSF    0A.3
....................          output_high(PIN_D7); 
0CBC:  BSF    03.5
0CBD:  BCF    08.7
0CBE:  BCF    03.5
0CBF:  BSF    08.7
....................          delay_ms(100); 
0CC0:  MOVLW  64
0CC1:  MOVWF  4E
0CC2:  BCF    0A.3
0CC3:  CALL   0F6
0CC4:  BSF    0A.3
....................          output_low(PIN_D7); 
0CC5:  BSF    03.5
0CC6:  BCF    08.7
0CC7:  BCF    03.5
0CC8:  BCF    08.7
....................          delay_ms(100); 
0CC9:  MOVLW  64
0CCA:  MOVWF  4E
0CCB:  BCF    0A.3
0CCC:  CALL   0F6
0CCD:  BSF    0A.3
....................          write_eeprom(0,temperature);  // 0 (0x00) adresine saniye deðerini yaz 
0CCE:  MOVF   0B,W
0CCF:  MOVWF  77
0CD0:  BCF    0B.7
0CD1:  BSF    03.6
0CD2:  CLRF   0D
0CD3:  BCF    03.6
0CD4:  MOVF   39,W
0CD5:  BSF    03.6
0CD6:  MOVWF  0C
0CD7:  BSF    03.5
0CD8:  BCF    0C.7
0CD9:  BSF    0C.2
0CDA:  MOVLW  55
0CDB:  MOVWF  0D
0CDC:  MOVLW  AA
0CDD:  MOVWF  0D
0CDE:  BSF    0C.1
0CDF:  BTFSC  0C.1
0CE0:  GOTO   4DF
0CE1:  BCF    0C.2
0CE2:  MOVF   77,W
0CE3:  BCF    03.5
0CE4:  BCF    03.6
0CE5:  IORWF  0B,F
....................          write_eeprom(1,humidity);   // 1 (0x01) adresine milisaniye deðerini yazr 
0CE6:  MOVF   0B,W
0CE7:  MOVWF  77
0CE8:  BCF    0B.7
0CE9:  MOVLW  01
0CEA:  BSF    03.6
0CEB:  MOVWF  0D
0CEC:  BCF    03.6
0CED:  MOVF   3A,W
0CEE:  BSF    03.6
0CEF:  MOVWF  0C
0CF0:  BSF    03.5
0CF1:  BCF    0C.7
0CF2:  BSF    0C.2
0CF3:  MOVLW  55
0CF4:  MOVWF  0D
0CF5:  MOVLW  AA
0CF6:  MOVWF  0D
0CF7:  BSF    0C.1
0CF8:  BTFSC  0C.1
0CF9:  GOTO   4F8
0CFA:  BCF    0C.2
0CFB:  MOVF   77,W
0CFC:  BCF    03.5
0CFD:  BCF    03.6
0CFE:  IORWF  0B,F
....................          write_eeprom(2,saniye); 
0CFF:  MOVF   0B,W
0D00:  MOVWF  77
0D01:  BCF    0B.7
0D02:  MOVLW  02
0D03:  BSF    03.6
0D04:  MOVWF  0D
0D05:  BCF    03.6
0D06:  MOVF   3B,W
0D07:  BSF    03.6
0D08:  MOVWF  0C
0D09:  BSF    03.5
0D0A:  BCF    0C.7
0D0B:  BSF    0C.2
0D0C:  MOVLW  55
0D0D:  MOVWF  0D
0D0E:  MOVLW  AA
0D0F:  MOVWF  0D
0D10:  BSF    0C.1
0D11:  BTFSC  0C.1
0D12:  GOTO   511
0D13:  BCF    0C.2
0D14:  MOVF   77,W
0D15:  BCF    03.5
0D16:  BCF    03.6
0D17:  IORWF  0B,F
....................          write_eeprom(3,dakika); 
0D18:  MOVF   0B,W
0D19:  MOVWF  77
0D1A:  BCF    0B.7
0D1B:  MOVLW  03
0D1C:  BSF    03.6
0D1D:  MOVWF  0D
0D1E:  BCF    03.6
0D1F:  MOVF   3C,W
0D20:  BSF    03.6
0D21:  MOVWF  0C
0D22:  BSF    03.5
0D23:  BCF    0C.7
0D24:  BSF    0C.2
0D25:  MOVLW  55
0D26:  MOVWF  0D
0D27:  MOVLW  AA
0D28:  MOVWF  0D
0D29:  BSF    0C.1
0D2A:  BTFSC  0C.1
0D2B:  GOTO   52A
0D2C:  BCF    0C.2
0D2D:  MOVF   77,W
0D2E:  BCF    03.5
0D2F:  BCF    03.6
0D30:  IORWF  0B,F
....................          write_eeprom(4,saat); 
0D31:  MOVF   0B,W
0D32:  MOVWF  77
0D33:  BCF    0B.7
0D34:  MOVLW  04
0D35:  BSF    03.6
0D36:  MOVWF  0D
0D37:  BCF    03.6
0D38:  MOVF   3D,W
0D39:  BSF    03.6
0D3A:  MOVWF  0C
0D3B:  BSF    03.5
0D3C:  BCF    0C.7
0D3D:  BSF    0C.2
0D3E:  MOVLW  55
0D3F:  MOVWF  0D
0D40:  MOVLW  AA
0D41:  MOVWF  0D
0D42:  BSF    0C.1
0D43:  BTFSC  0C.1
0D44:  GOTO   543
0D45:  BCF    0C.2
0D46:  MOVF   77,W
0D47:  BCF    03.5
0D48:  BCF    03.6
0D49:  IORWF  0B,F
....................          write_eeprom(5,gun); 
0D4A:  MOVF   0B,W
0D4B:  MOVWF  77
0D4C:  BCF    0B.7
0D4D:  MOVLW  05
0D4E:  BSF    03.6
0D4F:  MOVWF  0D
0D50:  BCF    03.6
0D51:  MOVF   3E,W
0D52:  BSF    03.6
0D53:  MOVWF  0C
0D54:  BSF    03.5
0D55:  BCF    0C.7
0D56:  BSF    0C.2
0D57:  MOVLW  55
0D58:  MOVWF  0D
0D59:  MOVLW  AA
0D5A:  MOVWF  0D
0D5B:  BSF    0C.1
0D5C:  BTFSC  0C.1
0D5D:  GOTO   55C
0D5E:  BCF    0C.2
0D5F:  MOVF   77,W
0D60:  BCF    03.5
0D61:  BCF    03.6
0D62:  IORWF  0B,F
....................          write_eeprom(6,ay); 
0D63:  MOVF   0B,W
0D64:  MOVWF  77
0D65:  BCF    0B.7
0D66:  MOVLW  06
0D67:  BSF    03.6
0D68:  MOVWF  0D
0D69:  BCF    03.6
0D6A:  MOVF   3F,W
0D6B:  BSF    03.6
0D6C:  MOVWF  0C
0D6D:  BSF    03.5
0D6E:  BCF    0C.7
0D6F:  BSF    0C.2
0D70:  MOVLW  55
0D71:  MOVWF  0D
0D72:  MOVLW  AA
0D73:  MOVWF  0D
0D74:  BSF    0C.1
0D75:  BTFSC  0C.1
0D76:  GOTO   575
0D77:  BCF    0C.2
0D78:  MOVF   77,W
0D79:  BCF    03.5
0D7A:  BCF    03.6
0D7B:  IORWF  0B,F
....................          write_eeprom(7,yil);          
0D7C:  MOVF   0B,W
0D7D:  MOVWF  77
0D7E:  BCF    0B.7
0D7F:  MOVLW  07
0D80:  BSF    03.6
0D81:  MOVWF  0D
0D82:  BCF    03.6
0D83:  MOVF   40,W
0D84:  BSF    03.6
0D85:  MOVWF  0C
0D86:  BSF    03.5
0D87:  BCF    0C.7
0D88:  BSF    0C.2
0D89:  MOVLW  55
0D8A:  MOVWF  0D
0D8B:  MOVLW  AA
0D8C:  MOVWF  0D
0D8D:  BSF    0C.1
0D8E:  BTFSC  0C.1
0D8F:  GOTO   58E
0D90:  BCF    0C.2
0D91:  MOVF   77,W
0D92:  BCF    03.5
0D93:  BCF    03.6
0D94:  IORWF  0B,F
....................          write_eeprom(8,gaz_seviyesi); 
0D95:  MOVF   0B,W
0D96:  MOVWF  77
0D97:  BCF    0B.7
0D98:  MOVLW  08
0D99:  BSF    03.6
0D9A:  MOVWF  0D
0D9B:  MOVLW  4A
0D9C:  MOVWF  0C
0D9D:  BSF    03.5
0D9E:  BCF    0C.7
0D9F:  BSF    0C.2
0DA0:  MOVLW  55
0DA1:  MOVWF  0D
0DA2:  MOVLW  AA
0DA3:  MOVWF  0D
0DA4:  BSF    0C.1
0DA5:  BTFSC  0C.1
0DA6:  GOTO   5A5
0DA7:  BCF    0C.2
0DA8:  MOVF   77,W
0DA9:  BCF    03.5
0DAA:  BCF    03.6
0DAB:  IORWF  0B,F
0DAC:  GOTO   49A
....................               } 
....................             while(input(PIN_E2)); 
0DAD:  BSF    03.5
0DAE:  BSF    09.2
0DAF:  BCF    03.5
0DB0:  BTFSC  09.2
0DB1:  GOTO   5AD
....................             restart_wdt();          
0DB2:  CLRWDT
....................       } 
....................    
....................  setup_WDT(WDT_2304MS);  
0DB3:  MOVLW  0F
0DB4:  MOVWF  77
0DB5:  CLRF   01
0DB6:  MOVLW  81
0DB7:  MOVWF  04
0DB8:  BCF    03.7
0DB9:  MOVF   00,W
0DBA:  ANDLW  F0
0DBB:  IORLW  07
0DBC:  MOVWF  00
0DBD:  CLRWDT
0DBE:  MOVF   00,W
0DBF:  ANDLW  F7
0DC0:  BTFSC  77.3
0DC1:  ANDLW  F0
0DC2:  IORWF  77,W
0DC3:  MOVWF  00
....................  normal_isi: 
....................       while(temperature<30) 
0DC4:  MOVF   39,W
0DC5:  SUBLW  1D
0DC6:  BTFSS  03.0
0DC7:  GOTO   634
....................       { 
....................  
....................         
....................          lcd_gotoxy(7,1); 
0DC8:  MOVLW  07
0DC9:  MOVWF  4E
0DCA:  MOVLW  01
0DCB:  MOVWF  4F
0DCC:  BCF    0A.3
0DCD:  CALL   17D
0DCE:  BSF    0A.3
....................          printf(lcd_putc,"\fSicaklik(%d C)",temperature); 
0DCF:  MOVLW  BF
0DD0:  BSF    03.6
0DD1:  MOVWF  0D
0DD2:  MOVLW  00
0DD3:  MOVWF  0F
0DD4:  BCF    03.0
0DD5:  MOVLW  0A
0DD6:  BCF    03.6
0DD7:  MOVWF  46
0DD8:  BCF    0A.3
0DD9:  CALL   33A
0DDA:  BSF    0A.3
0DDB:  MOVF   39,W
0DDC:  MOVWF  47
0DDD:  MOVLW  18
0DDE:  MOVWF  48
0DDF:  BCF    0A.3
0DE0:  CALL   3A3
0DE1:  BSF    0A.3
0DE2:  MOVLW  20
0DE3:  MOVWF  4D
0DE4:  BCF    0A.3
0DE5:  CALL   19F
0DE6:  BSF    0A.3
0DE7:  MOVLW  43
0DE8:  MOVWF  4D
0DE9:  BCF    0A.3
0DEA:  CALL   19F
0DEB:  BSF    0A.3
0DEC:  MOVLW  29
0DED:  MOVWF  4D
0DEE:  BCF    0A.3
0DEF:  CALL   19F
0DF0:  BSF    0A.3
....................          lcd_gotoxy(5,2); 
0DF1:  MOVLW  05
0DF2:  MOVWF  4E
0DF3:  MOVLW  02
0DF4:  MOVWF  4F
0DF5:  BCF    0A.3
0DF6:  CALL   17D
0DF7:  BSF    0A.3
....................          printf(lcd_putc,"Normal"); 
0DF8:  MOVLW  C7
0DF9:  BSF    03.6
0DFA:  MOVWF  0D
0DFB:  MOVLW  00
0DFC:  MOVWF  0F
0DFD:  BCF    0A.3
0DFE:  BCF    03.6
0DFF:  CALL   1C6
0E00:  BSF    0A.3
....................          delay_ms(250); 
0E01:  MOVLW  FA
0E02:  MOVWF  4E
0E03:  BCF    0A.3
0E04:  CALL   0F6
0E05:  BSF    0A.3
....................        
....................       output_high(normal); 
0E06:  BSF    03.5
0E07:  BCF    08.0
0E08:  BCF    03.5
0E09:  BSF    08.0
....................       output_low(input1); 
0E0A:  BCF    38.0
0E0B:  MOVF   38,W
0E0C:  BSF    03.5
0E0D:  MOVWF  07
0E0E:  BCF    03.5
0E0F:  BCF    07.0
....................       output_low(input2); 
0E10:  BCF    38.1
0E11:  MOVF   38,W
0E12:  BSF    03.5
0E13:  MOVWF  07
0E14:  BCF    03.5
0E15:  BCF    07.1
....................       output_low(buzzer); 
0E16:  BSF    03.5
0E17:  BCF    08.3
0E18:  BCF    03.5
0E19:  BCF    08.3
....................       output_low(tehlike); 
0E1A:  BSF    03.5
0E1B:  BCF    08.1
0E1C:  BCF    03.5
0E1D:  BCF    08.1
....................       output_low(uyari); 
0E1E:  BSF    03.5
0E1F:  BCF    08.2
0E20:  BCF    03.5
0E21:  BCF    08.2
....................        
....................        
....................       if(30<=temperature && temperature<=35) 
0E22:  MOVF   39,W
0E23:  SUBLW  1D
0E24:  BTFSC  03.0
0E25:  GOTO   62A
0E26:  MOVF   39,W
0E27:  SUBLW  23
0E28:  BTFSC  03.0
....................       { 
....................       goto tehlikeli_isi; 
0E29:  GOTO   634
....................       } 
....................             if(input(PIN_A4) && sayici==0) 
0E2A:  BTFSS  05.4
0E2B:  GOTO   631
0E2C:  MOVF   42,F
0E2D:  BTFSS  03.2
0E2E:  GOTO   631
....................             { 
....................              goto kesme; 
0E2F:  GOTO   05C
....................              break; 
0E30:  GOTO   634
....................             }        
....................              
....................       restart_wdt(); 
0E31:  CLRWDT
....................       break; 
0E32:  GOTO   634
0E33:  GOTO   5C4
....................       } 
....................        
....................       tehlikeli_isi: 
....................       while(30<=temperature && temperature<=35) 
0E34:  MOVF   39,W
0E35:  SUBLW  1D
0E36:  BTFSC  03.0
0E37:  GOTO   6A3
0E38:  MOVF   39,W
0E39:  SUBLW  23
0E3A:  BTFSS  03.0
0E3B:  GOTO   6A3
....................             { 
....................  
....................         
....................                 lcd_gotoxy(8,1); 
0E3C:  MOVLW  08
0E3D:  MOVWF  4E
0E3E:  MOVLW  01
0E3F:  MOVWF  4F
0E40:  BCF    0A.3
0E41:  CALL   17D
0E42:  BSF    0A.3
....................                 printf(lcd_putc,"\fSicaklik(%d C)",temperature); 
0E43:  MOVLW  CB
0E44:  BSF    03.6
0E45:  MOVWF  0D
0E46:  MOVLW  00
0E47:  MOVWF  0F
0E48:  BCF    03.0
0E49:  MOVLW  0A
0E4A:  BCF    03.6
0E4B:  MOVWF  46
0E4C:  BCF    0A.3
0E4D:  CALL   33A
0E4E:  BSF    0A.3
0E4F:  MOVF   39,W
0E50:  MOVWF  47
0E51:  MOVLW  18
0E52:  MOVWF  48
0E53:  BCF    0A.3
0E54:  CALL   3A3
0E55:  BSF    0A.3
0E56:  MOVLW  20
0E57:  MOVWF  4D
0E58:  BCF    0A.3
0E59:  CALL   19F
0E5A:  BSF    0A.3
0E5B:  MOVLW  43
0E5C:  MOVWF  4D
0E5D:  BCF    0A.3
0E5E:  CALL   19F
0E5F:  BSF    0A.3
0E60:  MOVLW  29
0E61:  MOVWF  4D
0E62:  BCF    0A.3
0E63:  CALL   19F
0E64:  BSF    0A.3
....................                 lcd_gotoxy(4,2); 
0E65:  MOVLW  04
0E66:  MOVWF  4E
0E67:  MOVLW  02
0E68:  MOVWF  4F
0E69:  BCF    0A.3
0E6A:  CALL   17D
0E6B:  BSF    0A.3
....................                 printf(lcd_putc,"Yukseliyor"); 
0E6C:  MOVLW  D3
0E6D:  BSF    03.6
0E6E:  MOVWF  0D
0E6F:  MOVLW  00
0E70:  MOVWF  0F
0E71:  BCF    0A.3
0E72:  BCF    03.6
0E73:  CALL   1C6
0E74:  BSF    0A.3
....................                 delay_ms(250); 
0E75:  MOVLW  FA
0E76:  MOVWF  4E
0E77:  BCF    0A.3
0E78:  CALL   0F6
0E79:  BSF    0A.3
....................  
....................                  
....................                 output_high(tehlike); 
0E7A:  BSF    03.5
0E7B:  BCF    08.1
0E7C:  BCF    03.5
0E7D:  BSF    08.1
....................                 output_high(buzzer); 
0E7E:  BSF    03.5
0E7F:  BCF    08.3
0E80:  BCF    03.5
0E81:  BSF    08.3
....................                 delay_ms(250); 
0E82:  MOVLW  FA
0E83:  MOVWF  4E
0E84:  BCF    0A.3
0E85:  CALL   0F6
0E86:  BSF    0A.3
....................                 output_low(tehlike); 
0E87:  BSF    03.5
0E88:  BCF    08.1
0E89:  BCF    03.5
0E8A:  BCF    08.1
....................                 output_low(buzzer); 
0E8B:  BSF    03.5
0E8C:  BCF    08.3
0E8D:  BCF    03.5
0E8E:  BCF    08.3
....................  
....................                  
....................                 if(temperature>35) 
0E8F:  MOVF   39,W
0E90:  SUBLW  23
0E91:  BTFSC  03.0
0E92:  GOTO   695
....................                 { 
....................                     goto asiri_isi; 
0E93:  GOTO   6A3
....................                 } 
0E94:  GOTO   699
....................                else if(temperature<30) 
0E95:  MOVF   39,W
0E96:  SUBLW  1D
0E97:  BTFSC  03.0
....................                { 
....................                     goto normal_isi; 
0E98:  GOTO   5C4
....................                } 
....................             if(input(PIN_A4) && sayici==0) 
0E99:  BTFSS  05.4
0E9A:  GOTO   6A0
0E9B:  MOVF   42,F
0E9C:  BTFSS  03.2
0E9D:  GOTO   6A0
....................             { 
....................              goto kesme; 
0E9E:  GOTO   05C
....................              break; 
0E9F:  GOTO   6A3
....................             }  
....................                restart_wdt(); 
0EA0:  CLRWDT
....................                 
....................                break; 
0EA1:  GOTO   6A3
0EA2:  GOTO   634
....................             } 
....................              
....................         asiri_isi:  
....................         while(temperature>35 && temperature<=40) 
0EA3:  MOVF   39,W
0EA4:  SUBLW  23
0EA5:  BTFSC  03.0
0EA6:  GOTO   711
0EA7:  MOVF   39,W
0EA8:  SUBLW  28
0EA9:  BTFSS  03.0
0EAA:  GOTO   711
....................    { 
....................     
....................          output_low(normal);  
0EAB:  BSF    03.5
0EAC:  BCF    08.0
0EAD:  BCF    03.5
0EAE:  BCF    08.0
....................          output_high(input1); 
0EAF:  BCF    38.0
0EB0:  MOVF   38,W
0EB1:  BSF    03.5
0EB2:  MOVWF  07
0EB3:  BCF    03.5
0EB4:  BSF    07.0
....................          output_low(input2); 
0EB5:  BCF    38.1
0EB6:  MOVF   38,W
0EB7:  BSF    03.5
0EB8:  MOVWF  07
0EB9:  BCF    03.5
0EBA:  BCF    07.1
....................           
....................  
....................          lcd_gotoxy(4,1); 
0EBB:  MOVLW  04
0EBC:  MOVWF  4E
0EBD:  MOVLW  01
0EBE:  MOVWF  4F
0EBF:  BCF    0A.3
0EC0:  CALL   17D
0EC1:  BSF    0A.3
....................          printf(lcd_putc,"\fSicaklikYukseldi %dC",temperature); 
0EC2:  MOVLW  D9
0EC3:  BSF    03.6
0EC4:  MOVWF  0D
0EC5:  MOVLW  00
0EC6:  MOVWF  0F
0EC7:  BCF    03.0
0EC8:  MOVLW  12
0EC9:  BCF    03.6
0ECA:  MOVWF  46
0ECB:  BCF    0A.3
0ECC:  CALL   33A
0ECD:  BSF    0A.3
0ECE:  MOVF   39,W
0ECF:  MOVWF  47
0ED0:  MOVLW  18
0ED1:  MOVWF  48
0ED2:  BCF    0A.3
0ED3:  CALL   3A3
0ED4:  BSF    0A.3
0ED5:  MOVLW  43
0ED6:  MOVWF  4D
0ED7:  BCF    0A.3
0ED8:  CALL   19F
0ED9:  BSF    0A.3
....................          lcd_gotoxy(5,2); 
0EDA:  MOVLW  05
0EDB:  MOVWF  4E
0EDC:  MOVLW  02
0EDD:  MOVWF  4F
0EDE:  BCF    0A.3
0EDF:  CALL   17D
0EE0:  BSF    0A.3
....................          printf(lcd_putc,"Fan Aktif"); 
0EE1:  MOVLW  E4
0EE2:  BSF    03.6
0EE3:  MOVWF  0D
0EE4:  MOVLW  00
0EE5:  MOVWF  0F
0EE6:  BCF    0A.3
0EE7:  BCF    03.6
0EE8:  CALL   1C6
0EE9:  BSF    0A.3
....................          output_high(buzzer); 
0EEA:  BSF    03.5
0EEB:  BCF    08.3
0EEC:  BCF    03.5
0EED:  BSF    08.3
....................          output_high(uyari); 
0EEE:  BSF    03.5
0EEF:  BCF    08.2
0EF0:  BCF    03.5
0EF1:  BSF    08.2
....................          delay_ms(100); 
0EF2:  MOVLW  64
0EF3:  MOVWF  4E
0EF4:  BCF    0A.3
0EF5:  CALL   0F6
0EF6:  BSF    0A.3
....................          output_low(uyari); 
0EF7:  BSF    03.5
0EF8:  BCF    08.2
0EF9:  BCF    03.5
0EFA:  BCF    08.2
....................          output_low(buzzer); 
0EFB:  BSF    03.5
0EFC:  BCF    08.3
0EFD:  BCF    03.5
0EFE:  BCF    08.3
....................           
....................            if(30<=temperature && temperature<=35) 
0EFF:  MOVF   39,W
0F00:  SUBLW  1D
0F01:  BTFSC  03.0
0F02:  GOTO   707
0F03:  MOVF   39,W
0F04:  SUBLW  23
0F05:  BTFSC  03.0
....................             { 
....................              goto tehlikeli_isi; 
0F06:  GOTO   634
....................             } 
....................             if(input(PIN_A4) && sayici==0) 
0F07:  BTFSS  05.4
0F08:  GOTO   70E
0F09:  MOVF   42,F
0F0A:  BTFSS  03.2
0F0B:  GOTO   70E
....................             { 
....................              goto kesme; 
0F0C:  GOTO   05C
....................              break; 
0F0D:  GOTO   711
....................             }  
....................             restart_wdt(); 
0F0E:  CLRWDT
....................             break; 
0F0F:  GOTO   711
0F10:  GOTO   6A3
....................   } 
....................        
....................       while(temperature>40) 
0F11:  MOVF   39,W
0F12:  SUBLW  28
0F13:  BTFSC  03.0
0F14:  GOTO   7A9
....................             { 
....................            
....................             output_high(buzzer); 
0F15:  BSF    03.5
0F16:  BCF    08.3
0F17:  BCF    03.5
0F18:  BSF    08.3
....................             output_high(uyari); 
0F19:  BSF    03.5
0F1A:  BCF    08.2
0F1B:  BCF    03.5
0F1C:  BSF    08.2
....................             output_high(input1); 
0F1D:  BCF    38.0
0F1E:  MOVF   38,W
0F1F:  BSF    03.5
0F20:  MOVWF  07
0F21:  BCF    03.5
0F22:  BSF    07.0
....................             output_low(input2); 
0F23:  BCF    38.1
0F24:  MOVF   38,W
0F25:  BSF    03.5
0F26:  MOVWF  07
0F27:  BCF    03.5
0F28:  BCF    07.1
....................             output_low(normal); 
0F29:  BSF    03.5
0F2A:  BCF    08.0
0F2B:  BCF    03.5
0F2C:  BCF    08.0
....................             output_low(tehlike); 
0F2D:  BSF    03.5
0F2E:  BCF    08.1
0F2F:  BCF    03.5
0F30:  BCF    08.1
....................              
....................  
....................             lcd_gotoxy(7,1); 
0F31:  MOVLW  07
0F32:  MOVWF  4E
0F33:  MOVLW  01
0F34:  MOVWF  4F
0F35:  BCF    0A.3
0F36:  CALL   17D
0F37:  BSF    0A.3
....................             printf(lcd_putc,"\fAsiri   (%d C)",temperature); 
0F38:  MOVLW  E9
0F39:  BSF    03.6
0F3A:  MOVWF  0D
0F3B:  MOVLW  00
0F3C:  MOVWF  0F
0F3D:  BCF    03.0
0F3E:  MOVLW  0A
0F3F:  BCF    03.6
0F40:  MOVWF  46
0F41:  BCF    0A.3
0F42:  CALL   33A
0F43:  BSF    0A.3
0F44:  MOVF   39,W
0F45:  MOVWF  47
0F46:  MOVLW  18
0F47:  MOVWF  48
0F48:  BCF    0A.3
0F49:  CALL   3A3
0F4A:  BSF    0A.3
0F4B:  MOVLW  20
0F4C:  MOVWF  4D
0F4D:  BCF    0A.3
0F4E:  CALL   19F
0F4F:  BSF    0A.3
0F50:  MOVLW  43
0F51:  MOVWF  4D
0F52:  BCF    0A.3
0F53:  CALL   19F
0F54:  BSF    0A.3
0F55:  MOVLW  29
0F56:  MOVWF  4D
0F57:  BCF    0A.3
0F58:  CALL   19F
0F59:  BSF    0A.3
....................             lcd_gotoxy(8,2); 
0F5A:  MOVLW  08
0F5B:  MOVWF  4E
0F5C:  MOVLW  02
0F5D:  MOVWF  4F
0F5E:  BCF    0A.3
0F5F:  CALL   17D
0F60:  BSF    0A.3
....................             printf(lcd_putc,"Sicaklik");          
0F61:  MOVLW  F1
0F62:  BSF    03.6
0F63:  MOVWF  0D
0F64:  MOVLW  00
0F65:  MOVWF  0F
0F66:  BCF    0A.3
0F67:  BCF    03.6
0F68:  CALL   1C6
0F69:  BSF    0A.3
....................             delay_ms(250); 
0F6A:  MOVLW  FA
0F6B:  MOVWF  4E
0F6C:  BCF    0A.3
0F6D:  CALL   0F6
0F6E:  BSF    0A.3
....................              
....................             if (input(PIN_A0)) // Eðer RA0 giriþindeki butona basýlýrsa 
0F6F:  BTFSS  05.0
0F70:  GOTO   78F
....................       { 
....................             delay_ms(20);  // Buton arkýný önlemek için 
0F71:  MOVLW  14
0F72:  MOVWF  4E
0F73:  BCF    0A.3
0F74:  CALL   0F6
0F75:  BSF    0A.3
....................             printf(lcd_putc,"\f");     
0F76:  MOVLW  0C
0F77:  MOVWF  4D
0F78:  BCF    0A.3
0F79:  CALL   19F
0F7A:  BSF    0A.3
....................             output_high(enable_b); 
0F7B:  BCF    38.7
0F7C:  MOVF   38,W
0F7D:  BSF    03.5
0F7E:  MOVWF  07
0F7F:  BCF    03.5
0F80:  BSF    07.7
....................             output_high(input3); 
0F81:  BCF    38.4
0F82:  MOVF   38,W
0F83:  BSF    03.5
0F84:  MOVWF  07
0F85:  BCF    03.5
0F86:  BSF    07.4
....................             output_low(input4); 
0F87:  BCF    38.5
0F88:  MOVF   38,W
0F89:  BSF    03.5
0F8A:  MOVWF  07
0F8B:  BCF    03.5
0F8C:  BCF    07.5
....................             restart_wdt();          
0F8D:  CLRWDT
....................       }   
0F8E:  GOTO   795
....................        
....................       else 
....................       { 
....................       output_low(enable_b); 
0F8F:  BCF    38.7
0F90:  MOVF   38,W
0F91:  BSF    03.5
0F92:  MOVWF  07
0F93:  BCF    03.5
0F94:  BCF    07.7
....................       } 
....................        
....................                if(35<temperature && temperature<=40) 
0F95:  MOVF   39,W
0F96:  SUBLW  23
0F97:  BTFSC  03.0
0F98:  GOTO   79F
0F99:  MOVF   39,W
0F9A:  SUBLW  28
0F9B:  BTFSS  03.0
0F9C:  GOTO   79F
....................             { 
....................              goto asiri_isi; 
0F9D:  GOTO   6A3
....................              break; 
0F9E:  GOTO   7A9
....................             }                   
....................              
....................             if(input(PIN_A4) && sayici==0) 
0F9F:  BTFSS  05.4
0FA0:  GOTO   7A6
0FA1:  MOVF   42,F
0FA2:  BTFSS  03.2
0FA3:  GOTO   7A6
....................             { 
....................              goto kesme; 
0FA4:  GOTO   05C
....................              break; 
0FA5:  GOTO   7A9
....................             }  
....................             restart_wdt();          
0FA6:  CLRWDT
....................             break; 
0FA7:  GOTO   7A9
0FA8:  GOTO   711
....................             } 
0FA9:  GOTO   095
....................  
....................   } 
....................  
.................... } 
0FAA:  SLEEP

Configuration Fuses:
   Word  1: 3F39   XT NOWDT NOPUT NOBROWNOUT NOLVP NOCPD NOWRT NODEBUG NOPROTECT
